vim9script noclear

if exists('guard') | finish | endif

var guard = true

# PHILOSOPHY
# @see https://www.moolenaar.net/habits.html
# @see http://www.viemu.com/a-why-vi-vim.html
# @see https://blog.sanctum.geek.nz/vim-koans/
# @see https://rwx.gg/tools/editors/vi/how/magic/
# @see https://whyisitsogood.wiki/Vim

# QUICKREF
# @see https://quickref.me/vim
# @see https://vim.rtorr.com/
# @see http://www.rayninfo.co.uk/vimtips.html
# @see http://www.angelwatt.com/coding/notes/vim-commands.html
# @see https://blog.sanctum.geek.nz/vim-annoyances/

# CVE
# @see https://www.cvedetails.com/vendor/8218/VIM.html

# CONFIG
# @see https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118
# @see https://blog.joren.ga/tools/vim-learning-steps
# @see https://learnvimscriptthehardway.stevelosh.com/
# @see https://github.com/flyingalex/Practical-Vim
# @see https://thevaluable.dev/code-quality-check-tools-php/
# @see https://bestasciitable.com/
# @see https://www.arp242.net/vimlog/
# @see https://github.com/mhinz/vim-galore
# @see https://gilesorr.com/blog/vim-variable-scope.html
# @see https://skippi.medium.com/ideas-for-non-leader-vim-mappings-fd32a2769c87

# ORIGIN
# @see https://www.reddit.com/r/vim/wiki/why_hjkl
# @see https://www.fcodelabs.com/2018/12/08/Vim-Cheats/
# @mailing  https://groups.google.com/g/vim_dev

# FROM SCRATCH TO PRO
# @see https://thevaluable.dev/vim-beginner/
# @see https://blog.sanctum.geek.nz/series/unix-as-ide/
# @thanks https://markodenic.com/use-google-like-a-pro/

# GAMES
# @see https://vimsnake.com/
# @see https://www.openvim.com/
# @see http://www.vimgenius.com/

# MAPS and MODES
#   n  Normal Mode: When typing commands.
#   i  Insert Mode.  These are also used in Replace Mode.
#   v  Visual Mode: When typing commands while the Visual area is highlighted.
#   s  Select Mode: like Visual but typing text replaces the selection.
#   x  Visual Mode and Select Mode
#   c  Command-line Mode: When entering a ":" or "/" command.
#   o  Operator-pending Mode: When an operator is pending (after "d", "y", "c", etc.).
#      Terminal Mode: When typing in a |:terminal| buffer.

# The following characters may be displayed before the {rhs} of the map:
#    *  The {rhs} of the map is not re-mappable. Defined using the ':noremap', ':nnoremap', ':inoremap', etc. commands.
#    &  Only script local mappings are re-mappable in the {rhs} of the map. The map command has the <script> attribute.
#    @  A buffer local map command with the <buffer> attribute.
# @see https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1)

# COMPARATIONS
#              use 'ignorecase'      match case     ignore case ~
# equal                 ==              ==#             ==?
# not equal             !=              !=#             !=?
# greater than          >               >#              >?
# greater than or equal >=              >=#             >=?
# smaller than          <               <#              <?
# smaller than or equal <=              <=#             <=?
# regexp matches        =~              =~#             =~?
# regexp doesn't match  !~              !~#             !~?
# same instance         is              is#             is?
# different instance    isnot           isnot#          isnot?

# Examples:
#   "abc" ==# "Abc"         evaluates to 0
#   "abc" ==? "Abc"         evaluates to 1
#   "abc" ==  "Abc"         evaluates to 1 if 'ignorecase' is set, 0 otherwise

# SEARCHING
#     \v    \m       \M       \V         matches ~
#         'magic' 'nomagic'
#     a     a        a        a          literal 'a'
#     \a    \a       \a       \a         any alphabetic character
#     .     .        \.       \.         any character
#     \.    \.       .        .          literal dot
#     $     $        $        \$         end-of-line
#     *     *        \*       \*         any number of the previous atom
#     ~     ~        \~       \~         latest substitute string
#     ()    \(\)     \(\)     \(\)       group as an atom
#     |     \|       \|       \|         nothing: separates alternatives
#     \\    \\       \\       \\         literal backslash
#     \{    {        {        {          literal curly brace

# REGEX
# Quantifiers::
#   *       ->  0 or more
#   +       ->  1 or more
#   ?       ->  0 or one
#   {#}     ->  Exact number
#   {#,#}   ->  Range of numbers {min,max}
# @regex https://www.youtube.com/watch?v=sa-TUpSx1JA

# THE WAY
# 1. Team Comprehension (Understand another code, yes: juniors)
# 2. Reduce Interruptions (Try different ways)
# 3. Extend Longetivity of Code (Minor changes, real refactor)
# 4. Prevent Unfinished Code (Tecnical  due? Finishs tasks)
# 5. Enforce Coding Standards (No diferent styles of code)
# 6. Document Chosen Patterns (Why X, why Y)
# 7. Review New Patterns Early (Bad decisions takes alone, then, ask!)
# 8. Never Expose Refactoring (Task for this, really: It's my responsability)
# 9. Assume Unexpected Change (Makes and takes decisions)

# WHY DON'T TRY NEOVIM
# 1. :W command -> Save as sudo don't work                  -> @see https://github.com/neovim/neovim/issues/1716 -> use suda.vim
# 2. :X command -> Encryption don't exist                   -> @see https://github.com/neovim/neovim/issues/701 -> use vim-gnupg
# 3. :R command -> Command with sudo don't work             -> @see #1
# 4. Mappings using <S-F#> don't work nativaly              -> @see https://github.com/neovim/neovim/issues/7384 -> Add extra mappings
# 5. Colorscheme built-in have weird colors                 -> @see https://www.reddit.com/r/neovim/comments/4urlge/vim_and_neovim_same_airline_theme_different/
# 6. Colorscheme in :terminal have weird colors             -> @see #5 (colors are old respect a Vim9) -> links colors in $VIMRUNTIME
# 7. In Linux terminal shows weird chars                    -> xdpyinfo?
# 8. Font size is always smaller (11pt)                     -> @see https://github.com/neovim/neovim/issues/6798
# n. Don't need installation
# @see https://vimhelp.org/version9.txt.html#new-9

# WHY TRY NEOVIM
# 1. No brake changes :(vim9script, yeah):                  -> @see https://www.youtube.com/watch?v=zPQSST-M3fM -> vim9script transpiler
# n. Faster, it's really (Of course, my setup) :D
# STARTUP TIME (plugins.time)
#           Version                     BARE(ms)    PLUG-NC(ms) PLUG-C(ms)
#   Vim9:   9.0.1-749 (no migrate)      4.336       112.298     221.233
#   Neovim: 0.6.1 (LuaJIT 2.1.0-beta3)  20.746      80.053      133.630
#   Diff:                               -378.4%     +28.7%      +39.5%
# @see https://neovim.io/doc/user/vim_diff.html
# @see https://www.murilopereira.com/the-values-of-emacs-the-neovim-revolution-and-the-vscode-gorilla/

# Registers and marks special used here
# - "z  Save content yank in function, this no overwrite default register
# - @z  Save temp content used in mappings
# - mZ  Save position (line and column) to recover after close all buffers (using <Leader>Z)

if !get(v:, 'vim_did_enter', !has('vim_starting'))
    def Initialize(cwd: string)
        g:cwd = cwd
        g:cache = {}
        g:isneovim = has('nvim')
        g:hasgit = isdirectory('.git')
        g:working = split(g:cwd, '/')[-2 :]
        g:istty = $TERM ==# 'linux' && !has('gui_running')

        # Load env vars
        g:env = {}

        # Translations result
        g:translation = []

        # Used in Grep command
        g:qfcommand = []

        # Day/Night
        # @see https://uxpickle.com/dark-or-light-mode-for-the-eyes/
        # @timezone https://24timezones.com/time-zone/est
        g:colorscheme = !g:istty
            ? (index(range(8, 16), str2nr(strftime('%H'))) >= 0 ? 'morning' : 'miningbox')
            : 'default'

        # Viminfofile setup
        g:infofile = ''

        # Save|Load sessions
        g:session_file = expand('~/.vim/sessions/' .. join(g:working, '@') .. '.vim')

        # Plugins
        # @see https://github.com/junegunn/vim-plug
        if empty(glob('~/.vim/autoload/plug.vim'))
                    \ || (fmod(str2float(strftime('%d')), 14.0) == 0.0 && strftime('%d') !=# strftime('%d', getftime(expand('~/.vim/autoload/plug.vim'))))
            # Try each n days to  update
            silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        endif
    enddef

    silent Initialize(getcwd())                                 # Initialize global variables

    filetype off                                                # Disabled while is processing...
    syntax off                                                  # ...

    set nomodeline                                              # Security!: Not read: /* vim: set filetype=idl */
                                                                # (default: Vim: on, Debian: off)
    set modelines=0                                             # Security!: None line is read it (default: 5)
    set secure                                                  # Security!: Not autocmd in .vimrc file (default: off)
    set exrc                                                    # Always search config in .vimrc file (default: off)
    set hidden                                                  # Allow change between buffer without save (default: off)

    # Maybe $LANG isn't set, then
    set encoding=utf-8                                          # Viminfo file encoding, but, I don't another (default: utf-8)
    set termencoding=utf-8                                      # Terminal encoding used in keyboard keys (default: tty=utf-8 konsole=empty)
    set fileencoding=utf-8                                      # Output encoding of the file that is written
                                                                # (default: empty, but fzf.vim=utf-8)

    set omnifunc=syntaxcomplete#Complete                        # Default complete function global (aka: i_CTRL-X_CTRL-O) (default: empty)
    set completefunc=syntaxcomplete#Complete                    # Default complete function in buffers (aka: i_CTRL-X_CTRL-U) (default: empty)
endif

# ALL in one BIG autocmd
execute 'augroup ALL1BIG'
autocmd!

set cpoptions-=a                                                # After :read <file> command NO set <file> as alternate buffer
set cpoptions-=A                                                # After :write <file> command NO set <file> as alternate buffer
set lazyredraw                                                  # No redraw when macro/script is running (default: off)
set redrawtime=3000                                             # Time for highlighting: +size need +time (default: 2000)
set nostartofline                                               # No move to column 0 after some actions: jump between hunk, Ctrl+d, dd, etc (default: on)

set nowritebackup                                               # No use backup before overwrite a file (default: depends). Use git!
set noswapfile                                                  # No swap for new buffer (default: on)
# Options:
# Relative or absoluts, explode by , (comma)
# Spaces must be escape with: \ (backslash)
# .     Relative to the directory of current file (non-recursively)
# ,,    Empty value = current work directory
# **    Any where, ex: /var/** (slower)
set path=.,,                                                    # Directories search when: gf, :find, :sfind, :tabfind
                                                                # Skip /usr/include, it's slow (default: .,/usr/include,,)

set sessionoptions=                                             # (default: blank,buffers,curdir,folds,help,options,tabpages,winsize,terminal)
set sessionoptions+=buffers                                     # Save buffers
set sessionoptions+=curdir                                      # Save current directory

# Better Search
set hlsearch                                                    # Highligth match results with /, ?, *, # (default: off)
set incsearch                                                   # Search first match while typing. On TOP return BOTTOM, on BOTTOM return TOP (default: off)

# @see https://blog.jcoglan.com/2017/05/08/merging-with-diff3/
set diffopt+=iwhite                                             # Ignore white spaces in diff mode
set diffopt+=vertical                                           # Start with vertical splits always
set diffopt+=indent-heuristic                                   # Use same indent of file
# @see https://deepai.org/publication/how-different-are-different-diff-algorithms-in-git-use-histogram-for-code-changes
set diffopt+=algorithm:histogram                                # Mayers Linear++
# @see https://github.com/lacygoill/config/blob/b76e5f3c57822d126b0bfcc327a8a27d3b8778ca/.vim/vimrc#L1206
set diffopt+=context:3                                          # Only 3 lines of context above/below a changed line (instead of 6)
set diffopt+=foldcolumn:1                                       # Use only 1 column for the foldcolumn, instead of 2 (vertical space is precious)
set diffopt+=followwrap                                         # Follow the 'wrap' option and leave as it is
set diffopt+=hiddenoff                                          # Turn off diff mode automatically for a buffer which becomes hidden
# @see https://vimhelp.org/diff.txt.html#diff_translations
g:diff_translations = 0

set wildmenu                                                    # Better command tab-completion (default: off)
set wildignore=                                                 # We never want to see them in command tab-completion (default: empty)
set wildignore+=*.gif,*.jpeg,*.jpg,*.mp3,*.mp4,*.png            # Media files aren't usable here

# Sanity?
set nrformats=                                                  # (default: bin,octal,hex)
set nrformats+=octal                                            # Incremente/Decrement binary numbers
set nrformats+=unsigned                                         # @see https://utcc.utoronto.ca/~cks/space/blog/unix/VimHandlingDashedNumbers

if executable('rg')
    # Replace built-in grep's Vim, options:
    # @see https://github.com/BurntSushi/ripgrep
    # @see https://docs.rs/regex/1.5.4/regex/#syntax
    # @see https://beyondgrep.com/feature-comparison/
    # @see http://vimcasts.org/episodes/search-multiple-files-with-vimgrep/
    # @see https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#automatic-filtering
    # @see https://gist.github.com/seanh/a866462a27cb3ad7b084c8e6000a06b9
    #  --no-messages:       No show warning messages if not found nothing
    #  --vimgrep:           Every match on its own line with line number and column
    #  --follow:            Follow symlinks (-L)
    #  --ignore-case:       Ignore lower and upper case (-i)
    #  --case-sensitive:    Respect lower and upper case (-s)
    #  --smart-case:        Uppercase are important!, if there is (-S)
    #  --fixed-strings      No use regex symbols (-F)
    #  --glob               Include or exclude dirs or files (-g). Examples: -g '!{.git,.svn}'
    set grepprg=rg\ --no-messages\ --vimgrep\ --follow          # Used in :grep command (default: grep -n $* /dev/null)

    #               ┌ %f file name (finds a string)
    #               │  ┌ %l line number (finds a number)
    #               │  │  ┌ %c column number (finds a number)
    #               │  │  │  ┌ %m error message (finds a string)
    #               │  │  │  │
    set grepformat=%f:%l:%c:%m,%f:%l:%m,%f:%l%m,%f\ \ %l%m      # (default: %f:%l:%m,%f:%l%m,%f %l%m)

    # Better integration's rg. Only Vim (or nvim 0.5+)
    # @thanks https://gist.github.com/romainl/56f0c28ef953ffc157f36cc495947ab3
    def Grep(...args: list<string>): string
        g:qfcommand = join([&grepprg] + [expandcmd(join(args, ' '))], ' ')

        return system(g:qfcommand)
    enddef

    def RGEscape(sentence: string): string
        var escaped = sentence

        escaped = substitute(escaped, '\\', '\\\\\\', 'g')
        escaped = substitute(escaped, '|', '\\|', 'g')

        return escaped
    enddef

    # Quickfix List
    command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
    # Location List
    command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
    # Update Quickfix List
    # @see https://vi.stackexchange.com/questions/13662/is-there-a-way-to-update-the-quickfix-entries-after-running-cdo-cfdo
    command! -nargs=0 -bar UP setqflist(map(getqflist(), 'extend(v:val, {"text":get(getbufline(v:val.bufnr, v:val.lnum),0)})'))

    # No learn new command, use :grep and :lgrep with superpowers
    cnoreabbrev <expr> grep (getcmdtype() ==# ':' && getcmdline() ==# 'grep') ? 'Grep' : 'grep'
    cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ? 'LGrep' : 'lgrep'

    # Open quickfix on finish command automatically
    augroup Quickfix
        autocmd!

        autocmd QuickFixCmdPost cgetexpr cwindow | setqflist([], 'a', {'title': ':' .. g:qfcommand})
        autocmd QuickFixCmdPost lgetexpr lwindow | setloclist(0, [], 'a', {'title': ':' .. g:qfcommand})
    augroup END
endif

# Better Completion
set complete=                                                   # (default: .,w,b,u,t,i)
set complete+=.                                                 # Current buffer
set complete+=w                                                 # Buffers in other [w]indows
set complete+=b                                                 # Buffers loaded in [b]uffers list (aka use RAM)
set complete+=u                                                 # Buffers [u]nloaded in buffers list (aka no use RAM)
set completeopt=                                                # Show preview in popup menu (default: menu,preview)
set completeopt+=menu                                           # Show list if items > 1
set completeopt+=noinsert                                       # No insert any text, user must be select a match, needs extra <C-n> with once option :|
set completeopt+=noselect                                       # No select any text, force user to select a match, needs extra <C-n> with once option :|
set pumheight=10                                                # Maximum options showed in popup menu (default: 0=all)

# Custom Interface
set autoread                                                    # Reload after external changes (default: off)
set autowrite                                                   # Save on lost focus (cycling buffers) (default: off)
set autoindent                                                  # Same indent after Enter, if Esc indent is deleted, less Spaces (default: off)
set backspace=indent,eol,start                                  # Allow backspacing over everything (default: depends)
set clipboard^=unnamedplus                                      # Shared SO clipboard (slower?)
                                                                #     then: buffer -> (no vim) => "+yy
                                                                #     then: (no vim) -> buffer => "+p or <S-Insert>
set splitbelow                                                  # :split  opens window below (default: off)
set splitright                                                  # :vsplit opens window right (default: off)
set signcolumn=yes                                              # Always show signs next to number (default: auto)
set cursorline                                                  # Highligth current line (default: off)
set cmdheight=2                                                 # More spaces, less "Enter to continue..." messages (default: 1)
set report=5                                                    # Less verbose (default: 2)

if has('mouse')
    set mouse=                                                  # Mouse disable always, allows copying from cmdline (default: "")
endif

set nowrap                                                      # No cut lines (default: on)
set linebreak                                                   # No cut words on wrap enable (default: off)
set showbreak=↪                                                 # Visual char on wrap line (default: empty)
set breakindent                                                 # Indent wrap lines better (default: off)
set display+=lastline                                           # Show as much as possible of the last line (default: empty)
set scrolloff=3                                                 # Preview before/after cursor (default: depends)
set sidescroll=3                                                # Scroll horizontally (default: 0=half-screen)
set sidescrolloff=5                                             # Preview horizontally scroll (default: 0=edge)

# Custom View
set number                                                      # Number in cursorline, no zero (default: off)
set numberwidth=5                                               # Number size, aka: 9999␣ (default: 4=999␣)
set relativenumber                                              # Relative number (slower) (default: off)
set textwidth=120                                               # Breakline in Insert Mode (default: depends filetype)
set synmaxcol=300                                               # Only highlight the first N columns (default: 3000)
#              └ weight in bytes
set updatetime=300                                              # Time await for any: git-gutter, events. RIP :redir

# @see https://utf8-icons.com/
set fillchars+=vert:│                                           # Better vertical split char

if !g:istty
    set listchars=space:·,eol:↲                                 # Chars used for invisible chars
    set listchars+=tab:⇥\ ,trail:␣,precedes:⇇,extends:⇉
else
    set ttyfast
    set listchars=space:\ ,eol:$                                # tty!
    set listchars+=tab:>\ ,trail:+,extends:>,precedes:<
endif

set winaltkeys=no                                               # Never use alt-keys for GUI menus (default: menu)
set guicursor=a:block                                           # Always cursor has same shape: block

if has('gui_running')
    set guicursor+=a:blinkon0                                   # Never blink the cursor (default: on)

    set guioptions=                                             # Reset option (default: aegimrLrT)
    set guioptions+=M                                           # Not sourced system [M]enu
    set guioptions+=g                                           # Show inactive items as inactive, [g]ray color (default: hide)
    set guioptions+=c                                           # Confirmations in [c]onsole (as Terminal)
    set guioptions+=k                                           # Windows [k]eep size after change GUI
    set guioptions+=!                                           # Use terminal with external commands, no simulate

    augroup GUIOptions
        autocmd GUIEnter * &g:guifont = substitute(&g:guifont, '^$', 'FiraCode Retina 14', '')
        # autocmd GUIEnter * &g:guifont = substitute(&g:guifont, '^$', 'Monospace 14', '')
        # autocmd GUIEnter * &g:guifont = substitute(&g:guifont, '^$', 'JetBrains Mono 14', '')
        # @see https://vimhelp.org/autocmd.txt.html#GUIFailed
        autocmd GUIFailed * qall

        # @thanks https://stackoverflow.com/questions/10259366/gvim-auto-copy-selected-text-to-system-clipboard-to-share-it-with-apps
        cnoremap <S-Insert> <C-r>+

        # @thanks https://github.com/tpope/dotfiles/blob/c31d6515e126ce2e52dbb11a7b01f4ac4cc2bd0c/.vimrc#L139
        nnoremap <silent> <A--> :&guifont = substitute(&guifont,'\d\+$','\=submatch(0)-1','')<Enter>
        nnoremap <silent> <A-+> :&guifont = substitute(&guifont,'\d\+$','\=submatch(0)+1','')<Enter>
    augroup END
endif

# Custom identation
set softtabstop=4                                               # Tabs calculate required spaces (default: 0)
set shiftwidth=4                                                # 1 tab === 4 spaces (default: 8)
set shiftround                                                  # Indentation to multiples of &shiftwidth 3>4>8 (default: off)
set expandtab                                                   # Don't use tabs please (default: off)
set fileformat=unix                                             # End of line as Unix format. Always! (default: depends)

# Avoid (unused) built-in plugins and: less code, fewer bugs
g:loaded_2html_plugin = 1
g:loaded_gzip = 1
g:loaded_logiPat = 1
g:loaded_rrhelper = 1
g:loaded_spellfile_plugin = 1
g:loaded_tar = 1
g:loaded_tarPlugin = 1
g:loaded_vimball = 1
g:loaded_vimballPlugin = 1
g:loaded_zip = 1
g:loaded_zipPlugin = 1

# Annoyoning (and distracting) behaviour with brakets, parenthesis, etc
g:loaded_matchparen = 1

# Netrw (require by :GBrowse command) allow edit remote files: <C-w>f, :edit, etc
# Key   Action
# enter Open files/directories
# o     Open file/directory in new horizontal split
# v     Open file/directory in new vertical split
# t     Open file/directory in new tab
# x     Open the file/directory with the default system app
# p     Preview file without (moving the cursor from netrw)

# -     Go up one directory
# u     Go back to previously visited directory (like <C-o> in Vim)
# U     Go forward to subsequently visited directory (like <C-i> in Vim)

# %     Create a new file
# d     Create a new directory
# D     Delete the file/directory under the cursor (or marked files/dirs)
# R     Rename/move file/directory

g:netrw_banner = 0                                          # Hide help banner. Toggle: I
g:netrw_keepdir = 1                                         # Keep current directory on preview files (p) (default: 1)
g:netrw_preview = 1                                         # Preview in vertical mode (default: horizontal)
g:netrw_alto = 1                                            # Change from above to below splitting (default: depends)
g:netrw_altv = 1                                            # Change from left to right splitting (default: depends)
g:netrw_browse_split = 4                                    # Open file vertically (default: 0=same window)
g:netrw_winsize = 20                                        # Keep same size after open file in previews (default: 50=50%)
g:netrw_liststyle = 3                                       # Show as tree: folders and files always. Cycling: i
g:netrw_localcopydircmd = 'cp -r'                           # Copy dirs recursive (default: cp)
g:netrw_list_hide = '^\.git\=/\=$,^\.\=/\=$'                # Hide some extensions: git and dotfiles
g:netrw_sizestyle = 'H'                                     # Human-readable: 5K, 4M, uses 1024 base (default: [b]ytes)

g:filterprg = split(&grepprg)[0] ==# 'rg'
    ? split(&grepprg)[0] .. ' -N'
    : split(&grepprg)[0] .. ' -E'

def GetNameCurrentPath(): string
    return index(['quickfix', 'terminal', 'help'], &buftype) < 0 && index(['netrw', 'vim-plug', 'fugitive'], &filetype) < 0
        ? split(g:cwd, '/')[-1] .. (expand('%:t') !=# '' ? ' ' : '')
        : ''
enddef

def GetNameCurrentFile(): string
    return &buftype !=# 'terminal' && index(['netrw', 'vim-plug', 'fugitive'], &filetype) < 0
        ? expand('%:~')
        : ''
enddef

def GetNameBranch(): string
    if &buftype ==# 'terminal' || index(['', 'qf', 'netrw', 'help', 'vim-plug', 'fugitive', 'GV', 'snippets'], &filetype) >= 0
        return ' '
    endif

    var branchname = fugitive#Head(8)

    return strlen(branchname) > 0 ? ' ' .. tolower(split(branchname, '/')[0]) .. ' ' : ' '
enddef

def GetVersion(executable: string): string
    if &filetype !=# 'php' || &buftype ==# 'terminal' || index(['', 'qf', 'netrw', 'help', 'vim-plug', 'fugitive', 'GV', 'snippets'], &filetype) >= 0
        return ''
    endif

    var ftime = getftime(fnamemodify(executable, ':p'))

    if ftime < 0
        return ''
    endif

    var [ctime, version] = get(g:cache, executable, [-2, ''])

    if ftime != ctime
        g:cache[executable] = [ftime, system("php --version | " .. g:filterprg .. " \"^PHP\" | awk '{print $2}' | tr -d \"\n\"")[0 : 2]]
    endif

    return ' ' .. version
enddef

def AsyncStatuslineFlag(): string
    if &buftype ==# 'terminal'
                \ || index(['', 'qf', 'netrw', 'help', 'vim-plug', 'fugitive', 'GV'], &filetype) >= 0
                \ || get(g:, 'asyncrun_hide', 0) ==# 1
        return g:test_strategy ==# 'background' ? ' ◎' : ''
    endif

    if index(['', 'running', 'stopped'], get(g:, 'asyncrun_status', '')) >= 0
        return get(g:, 'asyncrun_icon', '')
    endif

    if get(g:, 'asyncrun_status', '') ==# 'success'
        g:asyncrun_hide = 1
    endif

    if get(g:, 'asyncrun_play', 0)
        g:asyncrun_play = 0
        var command = 'aplay /usr/share/sounds/sound-icons/trumpet-12.wav'

        if get(g:, 'asyncrun_status', '') ==# 'failure'
            command = 'aplay /usr/share/sounds/sound-icons/pipe.wav'
        endif

        # Don't work using jobs :(
        silent system(command)
    endif

    g:asyncrun_status = 'stopped'

    return get(g:, 'asyncrun_icon', '')
enddef

set noruler                                                     # Position is showed in command-line (default: depends)
set showcmd                                                     # Current pending command in command-line and visual
                                                                # selection (default: depends) (slower)

set shortmess=                                                  # Reset option (default: filnxtToOS)
set shortmess+=a                                                # Enable [a]ll abbreviations
set shortmess+=W                                                # Don't give the "written" or "[w]" when [W]riting a file
set shortmess+=F                                                # Don't give the file in[F]o when editing a file
set shortmess+=A                                                # Don't give the "[A]TTENTION" message when swap is found
set shortmess+=I                                                # Don't give the [I]ntro message when starting Vim
set shortmess+=c                                                # Don't give ins-[c]ompletion-menu messages
                                                                #   - "-- XXX completion (YYY)"
                                                                #   - "match 1 of 2"
                                                                #   - "The only match"
                                                                #   - "Pattern not found"
                                                                #   - "Back at original"
set shortmess+=s                                                # Don't give "[s]earch hit BOTTOM, continuing at TOP"
set shortmess+=T                                                # Truncate o[T]hers message [...]
set shortmess+=t                                                # [t]runcate file message [<]
set shortmess+=C                                                # Don't give the "s[C]anning" message (Vim: >= 9.0.0738)

set laststatus=2                                                # Always show statusline (default: 1=if windows greater that 1)

def Statusline(lastmode: string): void
    if &previewwindow || pumvisible()
        return
    endif

    set statusline=                                             # Start from scratch (default: empty)
    var statusinfo = ''

    if index(['quickfix', 'terminal'], &buftype) >= 0 || index(['qf', 'netrw', 'vim-plug', 'fugitive', 'GV', 'snippets'], &filetype) >= 0
        statusinfo ..= ' '                                      # Extra space

        &statusline = statusinfo

        return
    endif

#     # Each window once time, ignore others events please, opening fzf kill statusline...
#     # @thanks https://github.com/vim-airline/vim-airline/blob/4f5b641710bc8cffddb28c6821b2ee7abaafefe6/plugin/airline.vim#L62
#     var uniqueid = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &filetype, lastmode]

#     if get(g:, 'statusline_unique', []) ==# uniqueid && &filetype !~? 'gitcommit'
#         return
#     endif

#     g:statusline_unique = uniqueid

    if index(['popup', 'help', 'man',], &buftype) >= 0
        statusinfo ..= ' '                                      # Extra space
        statusinfo ..= '%f'                                     # Relative filename

        &statusline = statusinfo

        return
    endif

    statusinfo ..= ' '                                          # Extra space

    # This expressions redraw statusline after save file always (slower)
    statusinfo ..= GetNameCurrentPath()                         # Relative path
    statusinfo ..= GetNameCurrentFile()                         # Relative filename

    statusinfo ..= '%='                                         # New group (align right)
    statusinfo ..= '%m'                                         # Modified flag
    statusinfo ..= '%r'                                         # Read-only flag
    statusinfo ..= (&wrap ? '[w]' : '')                         # Wrap flag
    statusinfo ..= (&wrapscan ? '' : '[s]')                     # Wrapscan flag
    statusinfo ..= (&paste ? '[p]' : '')                        # Paste flag
    statusinfo ..= (&virtualedit =~# 'all' ? '[v]' : '')        # Virtual edit flag

    if exists('g:loaded_test')
        statusinfo ..= AsyncStatuslineFlag()                    # Async process info
    endif

    if exists('g:loaded_pomodoro') && pomo#remaining_time() > 0 && !has('gui_running')
        statusinfo ..= ' '                                      # Extra space
        statusinfo ..= pomo#remaining_time() .. 'm'             # Pomodoro time
    endif

    statusinfo ..= GetNameBranch()                              # Branch name repository
    statusinfo ..= &filetype                                    # Is it require description?
    statusinfo ..= GetVersion('/etc/alternatives/php')          # PHP version

    statusinfo ..= '%<'                                         # Truncate long statusline here
    statusinfo ..= ' '                                          # Extra space
    statusinfo ..= &fileencoding                                # Is it require description?
    # statusinfo ..= ' '                                          # Extra space
    # statusinfo ..= 'c:%3c'                                      # Cursor [c]olumn

    statusinfo ..= ' '                                          # Extra space

    &statusline = statusinfo
enddef

# Maps
g:mapleader = "\<Space>"
g:maplocalleader = "\<Space>"
noremap <Space> <Nop>

# Purify! in Normal|Select|Operator Mode
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>

# Purify!! Good
inoremap <Up> <Nop>
inoremap <Down> <Nop>
inoremap <Left> <Nop>
inoremap <Right> <Nop>

# Purify!!! God
cnoremap <Up> <Nop>
cnoremap <Down> <Nop>
cnoremap <Left> <Nop>
cnoremap <Right> <Nop>

# Utility
# @tip Macro until end of buffer: VG:normal @x
nnoremap <silent> Q @@
# Don't add <C-u>
xnoremap <silent> Q :normal! @@<Enter>gv
# Don't work as expected. Works append chars
xnoremap <silent> . :normal! .<Enter>gv
nnoremap <silent> Y y$
xnoremap <silent> Y y
xnoremap <silent> $ $h
# 'x    Jump to the beginning of the line of mark 'x'
# `x    Jump to the cursor position of mark 'x'
nnoremap <silent> gl `.zzzv

# Emphasis in window, like <C-w>o, but don't close others
nnoremap <silent> <C-w>O :silent wincmd _ <Bar> silent wincmd <Bar><Enter>
tnoremap <silent> <C-w>O <C-\><C-n>:silent wincmd _ <Bar> silent wincmd <Bar> <Bar> normal i<Enter>

# Quickly resize
# @thanks https://stackoverflow.com/questions/53670098/vim-using-vcount1-as-argument-of-a-mapping
# NOTE: <Esc> is used to remove the range that Vim may insert (something like the CTRL-U does)
nnoremap <silent> <expr> <C-w>- (v:count > 0 ? "<Esc>" . v:count : 5) . "<C-w>-"
nnoremap <silent> <expr> <C-w>+ (v:count > 0 ? "<Esc>" . v:count : 5) . "<C-w>+"
nnoremap <silent> <expr> <C-w>< (v:count > 0 ? "<Esc>" . v:count : 5) . "<C-w><"
nnoremap <silent> <expr> <C-w>> (v:count > 0 ? "<Esc>" . v:count : 5) . "<C-w>>"

# Marks using exact position in Normal|Select|Operator Mode
noremap ` '
noremap ' `
noremap '' ``
noremap `` ''
# Center screen (zz) after search mark and open folds (zv)
noremap <silent> <expr> ' printf('`%czzzv', getchar())

# Not use [*|#]``zzzv, it throws error on 1 ocurrence
# Center screen (zz) after each search and open folds (zv)
nnoremap <silent> * *zzzv
nnoremap <silent> # #zzzv
nnoremap <silent> n nzzzv
nnoremap <silent> N Nzzzv
nnoremap <silent> <C-o> <C-o>zzzv
nnoremap <silent> <C-i> <C-i>zzzv
nnoremap <silent> <C-d> <C-d>zzzv
nnoremap <silent> <C-u> <C-u>zzzv

# Works as expected in Visual|Select Mode
xnoremap <silent> p "_dp
xnoremap <silent> P "_dP
xnoremap <silent> * "zy/\V<C-r>z<Enter>
xnoremap <silent> # "zy?\V<C-r>z<Enter>

# Undo break points (<C-g>u = Start new change)
inoremap <silent> , ,<C-g>u
inoremap <silent> ; ;<C-g>u
inoremap <silent> . .<C-g>u
inoremap <silent> : :<C-g>u
inoremap <silent> = =<C-g>u
inoremap <silent> ! !<C-g>u
inoremap <silent> ? ?<C-g>u
inoremap <silent> ( (<C-g>u
inoremap <silent> ) )<C-g>u
inoremap <silent> <C-w> <C-w><C-g>u
inoremap <silent> <C-u> <C-u><C-g>u
inoremap <silent> <Enter> <Enter><C-g>u

# Keep cursor position after join....?
# nnoremap <silent> <expr> J 'mz' .. v:count1 .. 'J`z'
# nnoremap <silent> <expr> J v:count1 > 1 ? 'JJ' : 'J'

# Move complete (n) lines selected (:move) and indent (gv=gv). Don't add <C-u>
xnoremap <silent> <expr> J ":move '>+" .. (v:count1) .. "\<Enter>gv=gv"
xnoremap <silent> <expr> K ":move '<-" .. (v:count1 + 1) .. "\<Enter>gv=gv"

# Save previous position in mark ', (<C-o> not works as expected)
# Using screen rows (g option), wrap works as you expect!
nnoremap <silent> <expr> j (v:count > 1 ? "m'" .. v:count : '') .. 'gj'
nnoremap <silent> <expr> k (v:count > 1 ? "m'" .. v:count : '') .. 'gk'
xnoremap <silent> j gj
xnoremap <silent> k gk

command! W execute 'silent! write !sudo tee % > /dev/null' <Bar> edit!

def Backup(file = ''): void
    var path = len(file) ==# 0 ? expand('%') : file

    if path ==# ''
        echohl WarningMsg
        echo 'Nothing to do.'
        echohl None

        return
    endif

    var result = system('cp -p ' .. path .. ' ' .. path .. '.' .. strftime('%Y%m%d%H%M%S'))

    if v:shell_error > 0                                        # <-- $? @see https://www.gnu.org/software/bash/manual/bash.html
        echohl WarningMsg
        echo result
        echohl None

        return
    endif

    echo 'Backup:   ' .. path

    return
enddef

# Backup rescue
command! -nargs=? -complete=file BB Backup(<f-args>)

# Don't write in update <- Sugar
cnoreabbrev <expr> w (getcmdtype() ==# ':' && getcmdline() ==# 'w') ? 'update' : 'w'

def FileFilter(isregex: bool, file: string, filter: string): void
    if file ==# ''
        echo 'Nothing to do.'

        return
    endif

    new
    setlocal noswapfile
    silent execute join([':0read', '!' .. (isregex ? g:filterprg : substitute(g:filterprg, ' -E', '', 'g') .. ' -F'), shellescape(filter), fnameescape(file)])
    normal gg
enddef

# [F]ilter data in files easily
# @see https://vimways.org/2019/vim-and-the-shell/
command! -nargs=? -bang F FileFilter(<bang>0, expand('%'), <f-args>)

# Sorry but :help is better
nmap <silent> <F1> <Nop>

# Open explore in current work directory (toggle)
nmap <silent> <expr> <F2> &filetype ==# 'netrw'
            \ ? ":bdelete!<Enter>"
            \ : ":silent execute '20Vexplore ' .. getcwd() <Bar> doautocmd <nomodeline> User UpdateStatusline<Enter>"

# Open explore in current file directory (toggle)
nmap <silent> <expr> <S-F2> &filetype ==# 'netrw'
            \ ? ":bdelete!<Enter>"
            \ : ":silent execute '20Vexplore' <Bar> doautocmd <nomodeline> User UpdateStatusline<Enter>"

# Fast Vim configuration (and plugins)
nmap <silent> <expr> <F10> expand('%:t') ==# '.vimrc'
            \ ? ":PlugUpdate<Enter>"
            \ : &filetype ==# 'vim-plug' ? ":silent execute \"normal! :bdelete!\\r\"<Enter>"
            \ : filereadable('.vimrc') ? ":silent execute 'edit .vimrc'<Enter>"
            \ : ":silent execute 'edit ~/.vimrc'<Enter>"

nnoremap <silent> <S-F10> :PlugClean<Enter>

# Turn-off highlighting
nnoremap <silent> <nowait> <expr> <Enter>
            \ &buftype ==# 'quickfix' ? "\rzzzv" :
            \ &buftype ==# 'nofile' && index(['vim', ''], &filetype) >= 0 ? "\r" :
            \ ":nohlsearch<Enter>"

# Preserve default register ("x) in Normal|Select|Operator Mode
noremap <silent> <Leader>x "_x
noremap <silent> <Leader>X "_X
noremap <silent> <Leader>c "_c
noremap <silent> <Leader>C "_C
noremap <silent> <Leader>d "_d
noremap <silent> <Leader>D "_D
noremap <silent> <Leader>s "_s
noremap <silent> <Leader>S "_S

# Show/Copied current filename (long path)
nnoremap <silent> <Leader>L <ScriptCmd>setreg('+', expand('%:p'))
            \ <Bar> echo 'Copied:   ' .. getreg('+')<Enter>

# Show/Copied current filename (only name)
nnoremap <silent> <Leader>N <ScriptCmd>setreg('+', expand('%:t'))
            \ <Bar> echo 'Copied:   ' .. getreg('+')<Enter>

# Copied current position (using relative path)
nnoremap <silent> <Leader>P <ScriptCmd>setreg('+', expand('%') .. ':' .. line('.'))
            \ <Bar> echo 'Copied:   ' .. getreg('+')<Enter>

# Improve search in fuzzy finder
nnoremap <silent> <Leader>f <ScriptCmd>FindFilter('find')<Enter>
xnoremap <silent> <Leader>f <Esc><ScriptCmd>FindFilter(visualmode())<Enter>

nnoremap <silent> <Leader>F <ScriptCmd>FindFilter('word')<Enter>
xnoremap <silent> <Leader>F <Esc><ScriptCmd>FindFilter('file')<Enter>

nnoremap <silent> <Leader>G <ScriptCmd>FindFilter('regex')<Enter>
xnoremap <silent> <Leader>G <Esc><ScriptCmd>FindFilter('regex')<Enter>

# Close current buffer (saving changes and buffer space)
nnoremap <silent> <expr> <Leader>z
            \ index(['', 'qf', 'netrw', 'help', 'vim-plug', 'fugitive', 'GV'], &filetype) >= 0
            \ ? ":bdelete!<Enter>"
            \ : ":update
            \ <Bar> if buflisted(bufnr('#')) == 1 && bufname('#') !=# ''
            \ <Bar>  edit #
            \ <Bar>  bdelete #
            \ <Bar> else
            \ <Bar>  bdelete
            \ <Bar> endif<Enter>"

# Close all except current buffer (saving changes)
nnoremap <silent> <Leader>Z :wall <Bar> execute "normal mZ" <Bar> %bdelete <Bar> execute "normal `Z" <Bar> bdelete # <Bar> delmarks Z<Enter>

nnoremap <silent> <Plug>AppendSemicolonRepeatable <ScriptCmd>AppendChar('a')<Enter>
nmap <silent> <Leader>as <Plug>AppendSemicolonRepeatable

nnoremap <silent> <Plug>DeleteFinalRepeatable <ScriptCmd>AppendChar('d')<Enter>
nmap <silent> <Leader>sa <Plug>DeleteFinalRepeatable

# Navigate through QuickFix
nnoremap <silent> <C-k> :<C-u>copen<Enter>
nnoremap <silent> <C-j> :<C-u>cclose<Enter>
nnoremap <silent> <C-h> :<C-u>colder<Enter>
nnoremap <silent> <C-l> :<C-u>cnewer<Enter>

# @simple https://github.com/tpope/vim-unimpaired
nnoremap <silent> [q :<C-u>cprevious<Enter>zzzv
nnoremap <silent> ]q :<C-u>cnext<Enter>zzzv
nnoremap <silent> [Q :<C-u>cfirst<Enter>zzzv
nnoremap <silent> ]Q :<C-u>clast<Enter>zzzv

# nnoremap <silent> [l :<C-u>lprevious<Enter>zzzv
# nnoremap <silent> ]l :<C-u>lnext<Enter>zzzv
# nnoremap <silent> [L :<C-u>lfirst<Enter>zzzv
# nnoremap <silent> ]L :<C-u>llast<Enter>zzzv

# nnoremap <silent> [b :<C-u>bprevious<Enter>
# nnoremap <silent> ]b :<C-u>bnext<Enter>
# nnoremap <silent> [B :<C-u>bfirst<Enter>
# nnoremap <silent> ]B :<C-u>blast<Enter>

nnoremap <silent> yol :<C-u>set list!<Enter>
nnoremap <silent> yoc :<C-u>set cursorline!<Enter>
nnoremap <silent> you :<C-u>set cursorcolumn!<Enter>
nnoremap <silent> yor :<C-u>set relativenumber!<Enter>
nnoremap <silent> yos :<C-u>set wrapscan!<Enter>
nnoremap <silent> yot :<C-u>set <C-r>=(&colorcolumn > 0)
            \ ? 'colorcolumn=0'
            \ : 'colorcolumn=121'<Enter><Enter>
nnoremap <silent> yow :<C-u>setlocal wrap!<Enter>
nnoremap <silent> yov :<C-u>setlocal <C-r>=(&virtualedit =~# 'all')
            \ ? 'virtualedit-=all'
            \ : 'virtualedit+=all'<Enter><Enter>

nnoremap <silent> <Leader>gC <ScriptCmd>GoUrl('https://www.color-hex.com/color/' .. substitute(expand('<cword>'), '#', '', 'g'))<Enter>

nnoremap <silent> <Leader>gs <ScriptCmd>setreg('+', strftime('%Y%m%d%H%M%S'))
            \ <Bar> echo 'Copied:   ' .. getreg('+')<Enter>

# Shortcuts for Date/Times in Insert Mode
inoremap <silent> <F6> <C-r>='Y-m-d'<Enter>
inoremap <silent> <S-F6> <C-r>=strftime('%Y-%m-%d')<Enter>
inoremap <silent> <F7> <C-r>='Y-m-d H:i:s'<Enter>
inoremap <silent> <S-F7> <C-r>=strftime('%Y-%m-%d %H:%M:%S')<Enter>

# Same!, but in Normal Mode
# Not use normal! <Bang>, it uses remaps
nnoremap <silent> <F6> :execute "normal a\<F6>\e"<Enter>
nnoremap <silent> <S-F6> :execute "normal a\<S-F6>\e"<Enter>
nnoremap <silent> <F7> :execute "normal a\<F7>\e"<Enter>
nnoremap <silent> <S-F7> :execute "normal a\<S-F7>\e"<Enter>

nnoremap <silent> <Leader>gP <ScriptCmd>setreg('+', GeneratePassword())
            \ <Bar> echomsg 'Copied:   ' .. getreg('+')<Enter>

nnoremap <silent> <Leader>gH <ScriptCmd>setreg('+', GenerateHash())
            \ <Bar> echomsg 'Copied:   ' .. getreg('+')<Enter>

nnoremap <silent> <Leader>gM <ScriptCmd>g:mask = GenerateMask('word')
            \ <Bar> if len(g:mask) > 0
            \ <Bar> setreg('+', g:mask[1])
            \ <Bar> echomsg 'Copied:   ' .. g:mask[0] .. ' -> ' .. getreg('+')
            \ <Bar> endif<Enter>

xnoremap <silent> <Leader>gM <ScriptCmd>g:mask = GenerateMask(visualmode())
            \ <Bar> if len(g:mask) > 0
            \ <Bar> setreg('+', g:mask[1])
            \ <Bar> echomsg 'Copied:   ' .. g:mask[0] .. ' -> ' .. getreg('+')
            \ <Bar> endif<Enter>

nnoremap <silent> <Plug>DeleteMethodRepeatable <ScriptCmd>DeleteMethod()<Enter>
nmap <silent> dm <Plug>DeleteMethodRepeatable

nnoremap <silent> <Plug>DeleteInnerCallRepeatable <ScriptCmd>DeleteCall('vbc', 'Inner')<Enter>
nmap <silent> dc <Plug>DeleteInnerCallRepeatable

def DeleteCall(flags: string, type: string): void
    silent FindFunction(flags)

    silent execute "normal! \"_dyi)\"_da)P"

    silent execute "normal! F("

    silent! repeat#set("\<Plug>Delete" .. type .. 'CallRepeatable')
enddef

# @thanks https://github.com/romgrk/nvim/blob/master/rc/keymap.vim#L761
def FindFunction(flags: string): void
    # @see :h search()
    var fcursor = flags =~# 'c' ? 'c' : ''
    var fbackward = flags =~# 'b' ? 'b' : ''
    var fnomove = flags =~# 'n' ? 'n' : ''
    var visual = flags =~# 'v' ? 1 : 0
    var saved_unnamed_register = getreg('@')

    var pattern = '\(\k\|\i\|\f\|<\|>\|:\|\\\)\+\s*\ze('

    if (visual)
        searchpos(pattern, fcursor .. fbackward, line('.'))

        silent execute "normal! v"

        searchpos(pattern, 'ce', line('.'))
    else
        searchpos(pattern, fcursor .. fbackward .. fnomove)
    endif

    setreg('@', saved_unnamed_register)
enddef

def DeleteMethod()
    var saved_unnamed_register = getreg('@')

    silent execute "normal! vaB\"_d-\"zyy+$"

    if match(getreg('z'), 'function ') >= 0
        silent execute "normal! \"_d-"
    endif

    var line = trim(getline('.'))

    if line ==# '}'
        # Last method
        silent execute "normal! -\"_dd"
    elseif line ==# ''
        # Empty line
        silent execute "normal! \"_dd"
    endif

    # Has docs (inline too)
    if trim(getline('.'))[-2 :] ==# '*/' || trim(getline(line('.') - 1))[-2 :] ==# '*/'
        var bsearch = getreg('/')

        silent execute "normal! ?\\/\\*\rd/\\*\\/\r\"_dd"

        silent setreg('/', bsearch)
        silent histdel('/', -1)
    endif

    setreg('@', saved_unnamed_register)

    silent! repeat#set("\<Plug>DeleteMethodRepeatable")
enddef

def FindFilter(type: string): void
    var saved_unnamed_register = getreg('@')
    var filter = ''

    if type ==# 'word' || type ==# 'file'
        filter = expand('<cword>')
    elseif type ==# 'v' || type ==# 'V'
        silent execute "normal! `<v`>\"zy"

        filter = getreg('z')
    endif

    setreg('@', saved_unnamed_register)

    if type ==# 'file'
        call fzf#vim#files(g:cwd, fzf#vim#with_preview({'options': ['--query', filter]}))
    elseif type ==# 'regex'
        call Rgfzf(filter, 0, '', 1)
    else
        call Rgfzf(filter, 0)
    endif
enddef

def AppendChar(type: string): void
    var saved_unnamed_register = getreg('@')
    var repeatable = 'AppendSemicolon'
    var screenrow = winline()
    var changerow = 0
    var ccursor = getpos('.')

    silent execute "normal! $v\"zy"
    var lastchar = getreg('z')

    try
        if type ==# 'd'
            silent execute "normal! $\"_x\e"
            repeatable = 'DeleteFinal'
        elseif type ==# 'i'
            var bsearch = getreg('/')
            changerow = -(1 + &scrolloff)

            silent execute "normal! ?^    {\rj"

            if match(getline('.'), '->mark') < 0
                silent execute "normal! O$this->markTestIncomplete();\e"
            endif

            silent setreg('/', bsearch)
            silent histdel('/', -1)
            repeatable = 'AddIncompleteMark'
        elseif type ==# 'I'
            var bsearch = getreg('/')
            changerow = -(1 + &scrolloff)

            silent execute "normal! ?^    {\rj"

            if match(getline('.'), '->mark') > 0
                silent execute "normal! \"_dd"
            endif

            silent setreg('/', bsearch)
            silent histdel('/', -1)
            repeatable = 'DropIncompleteMark'
        elseif lastchar ==# ';'
            silent execute "normal! \"_xA,\e"
        elseif lastchar ==# ','
            silent execute "normal! \"_xA;\e"
        elseif lastchar ==# ' '
            silent execute "normal! g_l\"_D\e"
        elseif index(['}'], lastchar) >= 0 && index(['json', 'javascript', 'typescript'], &filetype) >= 0
            silent execute "normal! A,\e"
        elseif index(['"', "'", ')', ']'], lastchar) >= 0 || match(lastchar, "\a") || match(lastchar, "\d")
            silent execute "normal! A;\e"
        else
            echo 'Nothing to do.'
            repeatable = ''
        endif
    catch
        changerow = 0

        echohl WarningMsg
        echo Exception()
        echohl None
    endtry

    silent cursor(ccursor)
    silent setpos('.', ccursor)

    if changerow != 0
        # Keep scroll in same position
        # Not use normal! <Bang>, it cancel printable char
        silent execute 'normal zt' .. (screenrow + changerow) .. "\<C-y>"

        echo substitute(repeatable, '\(\l\|\d\)\(\u\)', '\1 \l\2', 'g') .. ' applied.'
    endif

    setreg('@', saved_unnamed_register)

    if len(repeatable) > 0
        silent! repeat#set("\<Plug>" .. repeatable .. 'Repeatable', type)
    endif
enddef

# @see https://www.hivesystems.io/blog/are-your-passwords-in-the-green
def GeneratePassword(): string
    var password = system('openssl passwd -apr1 `openssl rand -base64 16` | tr -d "\n"')

    if strlen(password) ==# 0
        return 'Retry!'
    endif

    password = split(password, '\$')[2]
    password = substitute(password, '[4-6]', '\!', 'g')
    password = substitute(password, '[air]', '\*', 'g')
    password = substitute(password, '[HQZ]', '\@', 'g')

    return password[0 : 15]
enddef

def GenerateHash(): string
    var password = GeneratePassword()

    var hash = system('echo -n "' .. password .. '" | openssl dgst -sha256 | cut -d " " -f 2 | tr -d "\n"')

    return strlen(hash) > 0 && password !=# 'Retry!' ? hash : 'Retry!'
enddef

def GenerateMask(type: string): list<string>
    var saved_unnamed_register = getreg('@')
    var passphrase = ''

    if type ==# 'v' || type ==# 'V'
        silent execute "normal! `<v`>\"zy"

        passphrase = getreg('z')
    else
        passphrase = expand('<cword>')
    endif

    setreg('@', saved_unnamed_register)

    var escaped = Escape(passphrase)
    var mask = confirm('Select mask:', "&bcrypt\n&sha1\ns&ha256\n&rot13\n&md5", 1, 'Q')
    var command = ''

    # @see https://www.php.net/manual/en/features.commandline.options.php
    if mask ==# 0
        return []
    elseif mask ==# 1
        command = "php --run \"echo password_hash('" .. escaped .. "', PASSWORD_DEFAULT);\""
    elseif mask ==# 2
        command = "php --run \"echo hash('sha1', '" .. escaped .. "');\""
    elseif mask ==# 3
        command = "php --run \"echo hash('sha256', '" .. escaped .. "');\""
    elseif mask ==# 4
        command = "php --run \"echo str_rot13('" .. escaped .. "');\""
    elseif mask ==# 5
        command = "php --run \"echo md5('" .. escaped .. "');\""
    endif

    var masked = system(command)

    return [passphrase, (v:shell_error == 0 && strlen(masked) > 0 ? masked : 'Retry!')]
enddef

def GetMasked(type: string): void
    var saved_search_register = getreg('/')
    var saved_unnamed_register = getreg('@')
    var repeatable = ''

    var ccursor = getpos('.')
    var lsearch = getreg('/')

    if type ==# 'word'
        silent execute "normal! viw\"zy"

        repeatable = 'GetMasked'
    elseif type ==# 'v' || type ==# 'V'
        silent execute "normal! `<v`>\"zy"
    endif

    var selection = confirm('Select mask:', "&symbols\n&rot13", 1, 'Q')

    if selection ==# 0
        # Canceled
    elseif selection ==# 1
        # Replaced symbols -> * (no spaces)
        silent execute "s/\\%V[^a-zA-Z0-9 ]/*/ge"
        # Replaced chars -> @
        silent execute "s/\\%V[a-zA-Z]/@/ge"
        # Replaced numbers -> #
        silent execute "s/\\%V[0-9]/#/ge"
    elseif selection ==# 2
        var masked = system("php --run \"echo str_rot13('" .. Escape(getreg('z')) .. "');\"")

        silent execute "sno/\\%V" .. substitute(getreg('z'), '\/', '\\/', 'g') .. '/' .. substitute(masked, '\/', '\\/', 'g') .. "/e"
    endif

    silent cursor(ccursor)
    silent setpos('.', ccursor)
    silent setreg('/', lsearch)
    silent histdel('/', -1)

    setreg('@', saved_unnamed_register)
    setreg('/', saved_search_register)

    if len(repeatable) > 0
        silent! repeat#set("\<Plug>" .. repeatable .. 'Repeatable', type)
    endif
enddef

def Escape(sentence: string, ignorechars = []): string
    var escaped = sentence

    # Escape backslash (\)
    escaped = index(ignorechars, '\') >= 0 ? escaped : substitute(escaped, '\', '\\\\\\\\', 'g')
    # Escape double quotes (")
    escaped = index(ignorechars, '"') >= 0 ? escaped : substitute(escaped, '"', '\\"', 'g')
    # Escape single quotes (')
    escaped = index(ignorechars, "'") >= 0 ? escaped : substitute(escaped, "'", "\\\\'", 'g')
    # Escape dollar sign ($)
    escaped = index(ignorechars, '$') >= 0 ? escaped : substitute(escaped, '\$', '\\\$', 'g')
    # Escape pipe (|)
    # escaped = index(ignorechars, '|') >= 0 ? escaped : substitute(escaped, '|', '\\|', 'g')

    return escaped
enddef

def GoLine(): string
    try
        var separator = match(getline('.'), '(') > 0 ? '(' : ':'

        if match(getline('.'), separator) < 0
            throw 'Nothing to do.'
        endif

        var lbuffer = bufnr('%')
        var parts = split(trim(expand('<cWORD>'), '"'), separator)
        var file = strlen(parts[0]) > 0 ? parts[0] : ''
        var line = strlen(parts[1]) > 0 ? substitute(parts[1], '\D', '', 'g') : 1

        if filereadable(file) && len(line) > 0
            # Not use normal! <Bang>, it cancel printable char
            silent execute "normal \<C-w>w"
            silent execute 'edit +' .. line .. ' ' .. fnameescape(file)
        endif

        if index(['php'], &filetype) >= 0 && index(['terminal', 'quickfix'], getbufvar(lbuffer, '&buftype')) >= 0
            silent execute lbuffer .. 'bdelete!'
        endif
    catch /^Nothing/
        echo 'Nothing to do.'
    catch
        echohl WarningMsg
        echo Exception()
        echohl None
    endtry

    # Avoid weird chars in command line
    return ''
enddef

# Docs rescue
# @thanks https://github.com/Phantas0s/.dotfiles
nnoremap <silent> <Leader>gd <ScriptCmd>GoDocs(expand('<cword>'))<Enter>

def GoDocs(searchable: string): void
    var word = searchable
    var docsurl = 'https://devdocs.io/#q='

    if &filetype ==# 'php'
        docsurl = 'https://www.php.net/'
    elseif &filetype ==# 'vim-plug'
        docsurl = substitute(g:plugs[word].uri, 'git::@', '', 'g')
        word = ''
    elseif expand('%:t') ==# 'composer.json'
        docsurl = 'https://github.com/'
    elseif expand('%:t') ==# 'package.json'
        docsurl = 'https://www.npmjs.com/package/'
    elseif expand('%:t') ==# 'Dockerfile' && match(getline('.'), 'FROM') >= 0
        docsurl = 'https://hub.docker.com/r/'
        var saved_unnamed_register = getreg('@')

        silent execute "normal! 0wviW\"zy"

        word = split(getreg('z'), ':')[0]

        setreg('@', saved_unnamed_register)
    elseif index(['vim'], &filetype) >= 0 && match(getline('.'), 'Plug') >= 0
        docsurl = 'https://github.com/'
        var saved_unnamed_register = getreg('@')

        silent execute "normal! 0vi'\"zy"

        word = getreg('z')

        setreg('@', saved_unnamed_register)
    elseif index(['help'], &filetype) >= 0
        docsurl = 'https://duckduckgo.com/?sites=vimhelp.org&ia=web&q='
    elseif index(['vim'], &filetype) >= 0
        silent ShowDocumentation()

        return
    elseif index(['terminal'], &buftype) >= 0
        return
    endif

    silent GoUrl(docsurl .. word)
enddef

nnoremap <silent> <Plug>GetMaskedRepeatable <ScriptCmd>GetMasked('word')<Enter>
nmap <silent> <Leader>gm <Plug>GetMaskedRepeatable

xnoremap <silent> <Leader>gm <Esc><ScriptCmd>GetMasked(visualmode())<Enter>

# Buffers navigation
nnoremap <silent> <Leader><Leader> <ScriptCmd>Buffers<Enter>
nnoremap <silent> <Tab> <ScriptCmd>CyclingBuffers(1)<Enter>

xnoremap <silent> <Leader><Leader> <Esc><ScriptCmd>Buffers<Enter>
# Snippets using $VISUAL with :vnoremap fails!
xnoremap <silent> <Tab> <Esc><ScriptCmd>CyclingBuffers(1)<Enter>

# @simple https://github.com/tpope/vim-rsi
# Insert Mode navigation (Forget Arrows)
inoremap <silent> <C-a> <C-o>^
inoremap <silent> <C-e> <C-o>$
inoremap <silent> <C-k> <C-o>k
inoremap <silent> <C-j> <C-o>j
inoremap <silent> <C-h> <C-o>h
inoremap <silent> <C-l> <C-o>l
inoremap <silent> <C-b> <C-o>B
inoremap <silent> <C-f> <C-o>W

# Same behaviour in Insert Mode
inoremap <silent> <C-z> <Esc><C-z>
# Completions using only current buffer (avoids delay with <C-n> when I open logs files)
# Also allows 1 char as base completion (<C-n> requires at least two)
inoremap <silent> <C-n> <C-x><C-n>
inoremap <silent> <C-x><C-n> <C-n>

# Command Mode navigation (Forget Arrows). Not add <silent> option
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-k> <Up>
cnoremap <C-j> <Down>
cnoremap <C-h> <Left>
cnoremap <C-l> <Right>
cnoremap <C-b> <C-Left>
cnoremap <C-f> <C-Right>

# Auto-complete files in command line using RegEx (aka: bd *.json<C-x><C-a>)
# @see https://stackoverflow.com/questions/3155461/how-to-delete-multiple-buffers-in-vim
cnoremap <C-x><C-a> <C-a>
# Shortcuts to recurrent files or directories
cnoremap <C-x><C-d> ~/Downloads/
cnoremap <C-x><C-h> /var/www/html/
cnoremap <C-x><C-f> <C-u>set filetype=
cnoremap <C-x><C-e> =join(['~/working', g:working[0], 'CODE', g:working[1], '.env'], '/')<Enter>
cnoremap <C-x><C-t> =join(['~/working', g:working[0], 'CODE', g:working[1], '.env.testing'], '/')<Enter>
cnoremap <C-x><C-q> =join(['~/working', g:working[0], 'CODE', g:working[1], g:working[1] .. '.sql'], '/')<Enter>

def CyclingBuffers(incr: number): void
    var abuffer = bufnr('#')
    var cbuffer = bufnr('%')

    if incr == 1
                \ && cbuffer != abuffer
                \ && buflisted(abuffer) == 1
                \ && getbufvar(abuffer, '&filetype') !=# 'help'
        try
            silent execute "normal! \<C-^>g`\""
        catch /^Vim\%((\a\+)\)\=:E19/
        catch /^Vim\%((\a\+)\)\=:E20/
            echo 'Last position not found.'
        catch /^Vim\%((\a\+)\)\=:E211/
            echo 'File not found.'
        endtry

        return
    endif

    var lbuffer = bufnr('$')
    var nbuffer = cbuffer + incr

    while 1
        if nbuffer != 0
                    \ && buflisted(nbuffer) == 1
                    \ && getbufvar(nbuffer, '&filetype') !=# 'help'
            silent execute 'buffer ' .. nbuffer

            break
        else
            nbuffer = nbuffer + incr

            if nbuffer < 1
                nbuffer = lbuffer
            elseif nbuffer > lbuffer
                nbuffer = 1
            endif

            if nbuffer == cbuffer
                if g:hasgit
                    silent execute 'GFiles'
                else
                    silent execute 'Files'
                endif

                break
            endif
        endif
    endwhile
enddef

set notimeout                                                   # Wait for key mappings sequence to complete (default: on)
set ttimeout                                                    # Wait for key code sequence to complete (default: off)
set ttimeoutlen=10                                              # Wait 10ms after Esc for special key (aka: preview fzf) (default: -1)

augroup FastEscape
    autocmd!

    # Don't await after Esc in Insert Mode
    autocmd InsertEnter * set timeoutlen=0
    autocmd InsertLeave * set timeoutlen=1000
augroup END

plug#begin('~/.vim/plugged')

Plug 'tpope/vim-commentary'                                     # gcc, {motion}gc
Plug 'tpope/vim-surround'                                       # cs"' ([c]hange), ds" ([d]elete)
Plug 'tpope/vim-repeat'                                         # Repeat: surround, git-gutter and other more
Plug 'wellle/targets.vim'                                       # {operator}ia, {operator}aa -> [a]rgument
Plug 'machakann/vim-swap'                                       # Swap args: g>, g<, gs (interactive)
# Plug 'Raimondi/delimitMate'                                     # Append close: ', ", ), ], etc

# Plug 'neoclide/coc.nvim', {'branch': 'release'}                 # Autocomplete (LSP)
Plug 'dense-analysis/ale'                                       # Diagnostic code on-the-fly
Plug 'junegunn/fzf', {'do': { -> fzf#install() }}               # Open and find files
Plug 'junegunn/fzf.vim'                                         # Using a fuzzy finder
Plug 'SirVer/ultisnips'                                         # Performance using shortcuts
Plug 'sniphpets/sniphpets'                                      # PHP snippet with namespace resolve (needs ultisnips)

Plug 'tpope/vim-fugitive'                                       # Git with superpowers (statusline, GB and GBrowse commands, etc)
Plug 'junegunn/gv.vim', {'on': 'GV'}                            # - Commits filter extension (needs vim-fugitive) -> :GV[!], GV?
Plug 'tpope/vim-rhubarb'                                        # - GitHub browser extension (needs vim-fugitive) -> :GBrowse
Plug 'tommcdo/vim-fubitive'                                     # - BitBucket browser extension (needs vim-fugitive) -> :GBrowse
Plug 'airblade/vim-gitgutter'                                   # Show signs changes if cwd is a git repository

Plug 'tpope/vim-dadbod'                                         # DB console in Vim
Plug 'kristijanhusak/vim-dadbod-completion', {'for': ['sql']}   # DB autocompletion (needs vim-dadbod)

# Plug 'preservim/tagbar', {'for': ['php', 'c']}                  # Navigate: methods, vars, etc
# Plug 'vim-php/tagbar-phpctags.vim', {'for': 'php'}              # Tagbar addon for PHP in on-the-fly

Plug 'vim-test/vim-test', {'for': 'php'}                        # Run test: <Leader>{tt|tf|ts|tl|tg|tq}
Plug 'skywind3000/asyncrun.vim', {'for': 'php'}                 # Run async tasks: tests, commits, etc in background

Plug 'phpactor/phpactor', {'for': 'php', 'do': 'composer install --no-dev -o'} # LSP and refactor tool for PHP

# Plug 'vim-scripts/autotags', {'for': 'c'}

# Plug 'AndrewRadev/tagalong.vim', {'for': ['html', 'xml', 'vue']}" Rename html tags easily
# Plug 'mattn/emmet-vim', {'for': ['html', 'css', 'javascript', 'vue']}   # Performance using emmet syntax

Plug 'machakann/vim-highlightedyank'                            # See yank preview
Plug 'markonm/traces.vim'                                       # See range, substitution and global preview
Plug 'jamessan/vim-gnupg'                                       # Transparent editing of gpg encrypted files
Plug 'kshenoy/vim-signature'                                    # Show marks in signcolumn
# Plug 'voldikss/vim-browser-search'                              # Search in browser

Plug 'junegunn/goyo.vim', {'on': 'Goyo'}                        # Zen mode +
Plug 'junegunn/limelight.vim', {'on': 'Limelight'}              # Zen mode ++
Plug 'tricktux/pomodoro.vim', {'on': 'PomodoroStart'}           # Zen mode +++
Plug 'wakatime/vim-wakatime'                                    # Zen mode ++++

# Plug 'ap/vim-css-color',  {'for': [
#             \ 'html',
#             \ 'css',
#             \ 'javascript',
#             \ 'vue',
#             \ 'vim'
#             \ ]}                                                # Preview html colors

# Plug '91khr/rainbow'                                            # Better reading
# Plug 'lacygoill/vim9-syntax'                                    # Better highlight vim9script
# Plug 'StanAngeloff/php.vim', {'for': 'php'}                     # Better highlight PHP syntax: unmanteined 2020-05-28
# Plug 'octol/vim-cpp-enhanced-highlight', {'for': 'c'}           # Better highlight C syntax
# Plug 'mboughaba/i3config.vim', {'for': 'i3config'}              # Better highlight i3 syntax
# Plug 'storyn26383/vim-vue', {'for': 'vue'}                      # Better highlight vue syntax
# Plug 'tpope/vim-markdown', {'for': 'markdown'}                  # Better highlight markdown syntax (slower?)
# Plug 'MTDL9/vim-log-highlighting'                               # Better highlight log syntax
# Plug 'ekalinin/dockerfile.vim'                                  # Better highlight dockerfile syntax (better?)
# Plug 'pangloss/vim-javascript'                                  # Better highlight javascript syntax

Plug 'freddiegar/miningbox.vim'                                 # Finally colorscheme

plug#end()


# Use ALE to diagnostics
# LSP       ->  Language(s)
# PHPActor  ->  php
# CLangd    ->  c, c++
# TsServer  ->  typescript, javascript
# Vetur     ->  vue

# @see https://github.com/neoclide/coc.nvim/blob/master/doc/coc-config.txt
# ~/.vim/coc-settings.json
# {
#    "coc.preferences.extensionUpdateCheck": "weekly",
#    "coc.preferences.snippetStatusText": "SNIPPET  ",
#    "coc.source.around.priority": 1,
#    "coc.source.buffer.priority": 2,
#    "coc.source.file.priority": 10,
#    "diagnostic.enable": false,
#    "diagnostic.enableSign": false,
#    "diagnostic.signOffset": 9999999,
#    "notification.disabledProgressSources": ["*"],
#    "suggest.enablePreselect": false,
#    "suggest.languageSourcePriority": 99,
#    "suggest.maxCompleteItemCount": 20,
#    "suggest.minTriggerInputLength": 2,
#    "suggest.noselect": true,
#    "suggest.removeDuplicateItems": true,
#    "suggest.selection": "recentlyUsed",
#    "suggest.snippetIndicator": "",
#    "suggest.triggerCompletionWait": 100,
#    "phpactor.enable": true,
#    "phpactor.path": "~/.vim/plugged/phpactor/bin/phpactor",
#    "clangd.enable": true,
#    "clangd.path": "/usr/local/clang_9.0.0/bin/clangd",
#    "vetur.ignoreProjectWarning": true
# }

# ~/.config/phpactor/phpactor.json
# {
#  "language_server_code_transform.import_globals": true,
#  "language_server_completion.trim_leading_dollar": true,
#  "file_path_resolver.enable_logging": true,
#  "indexer.exclude_patterns": [
#    "\/tests\/coverage\/**\/*",
#    "\/vendor\/**\/Tests\/**\/*",
#    "\/vendor\/**\/tests\/**\/*",
#    "\/vendor\/composer\/**\/*"
#  ]
# }

# PHPActor
# @see https://github.com/phpactor/phpactor
g:phpactorPhpBin = "/usr/bin/php8.1"

# LSP Vue
# npm -g install vls eslint eslint-plugin-vue -D

# # Search Browser
# # @see https://github.com/voldikss/vim-browser-search
# g:browser_search_default_engine = 'duckduckgo'

# nmap <silent> <Leader>S <Plug>SearchNormal
# xmap <silent> <Leader>S <Plug>SearchVisual

# command! -nargs=* -range S search#start(<q-args>, visualmode(), <range>)

# # DelitMate
# # @see https://github.com/Raimondi/delimitMate
# g:delimitMate_expand_cr = 1
# g:delimitMate_smart_quotes = 1
# g:delimitMate_expand_inside_quotes = 0
# g:delimitMate_smart_matchpairs = '^\%(\w\|\$\)'

# @thanks https://github.com/skanehira/translate.vim
def TranslateResult(channel: channel, message: string)
    silent add(g:translation, message)
enddef

def TranslateView(channel: job, message: number)
    # Don't add silent
    TranslateShow()
enddef

def TranslateShow()
    if empty(g:translation)
        echohl WarningMsg
        echo 'Nothing to do.'
        echohl None

        return
    endif

    setreg('+', join(g:translation))

    echo getreg('+')
enddef

def Translate(range: number, inverse: bool, ...options: list<string>): void
    g:translation = []

    var source = len(options) >= 2 ? 1 : 'en'
    var target = len(options) >= 2 ? options[2] : (len(options) >= 1 ? 1 : 'es')
    var fwords = len(options) >= 2 ? options[2 :] : (len(options) >= 1 ? options[1 :] : (len(options) ==# 1 ? options : []))
    var content = GetSelection(range, 0, fwords)
    var command = ['curl', '-s', '-L', 'https://script.google.com/macros/s/AKfycbywwDmlmQrNPYoxL90NCZYjoEzuzRcnRuUmFCPzEqG7VdWBAhU/exec', '-d']

    if inverse
        command = command + [json_encode({'source': target, 'target': source, 'text': content})]
    else
        command = command + [json_encode({'source': source, 'target': target, 'text': content})]
    endif

    echo 'Translating...'

    job_start(command, {
                \ 'out_cb': function('TranslateResult'),
                \ 'err_cb': function('TranslateResult'),
                \ 'exit_cb': function('TranslateView'),
                \ })
enddef

command! -nargs=* -range -bang T Translate(<range>, <bang>0, <f-args>)

# Snippets (Default Maps: <Tab> <C-j> <C-k>)
# @see https://github.com/SirVer/ultisnips
# @see https://developpaper.com/vim-code-snippet-plug-in-ultisnips-usage-tutorial/
# @options https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt#L662
# IMPORTANT: Custom g:UltiSnipsExpandTrigger MUST BE DIFF to <Tab> to integration CoC
# IMPORTANT: Custom g:UltiSnipsJumpForwardTrigger MUST BE KEEP diferent to g:UltiSnipsExpandTrigger
g:UltiSnipsEditSplit = 'vertical'
g:UltiSnipsListSnippets = ''
g:UltiSnipsExpandTrigger = '<C-Tab>'
g:UltiSnipsRemoveSelectModeMappings = 0
g:UltiSnipsUsePythonVersion = 3

# # Emmet
# # @see https://github.com/mattn/emmet-vim
# # Only enable in [I]nsert Mode, in [N]ormal Mode f, F, t, T don't work!
# g:user_emmet_mode = 'i'
# g:user_emmet_leader_key = ','
# g:user_emmet_install_global = 0

# Goyo
# @see https://github.com/junegunn/goyo.vim
g:goyo_linenr = 1
g:goyo_width = 123
g:goyo_height = '100%'
g:goyo_bg = '#1D2021'

nmap <silent> <F12> :Goyo<Enter>

# Limelight
# @see https://github.com/junegunn/limelight.vim
# Number of preceding/following paragraphs to include (default: 0)
g:limelight_paragraph_span = 2

# Pomodoro
# @see https://github.com/tricktux/pomodoro.vim
g:pomodoro_time_work = 50
g:pomodoro_time_slack = 10
g:pomodoro_notification_cmd = 'aplay /usr/share/sounds/sound-icons/prompt.wav'

nmap <silent> <F3> :execute "PomodoroStart in " .. g:working[1] <Bar> doautocmd <nomodeline> User UpdateStatusline<Enter>
nmap <silent> <S-F3> :PomodoroStatus<Enter>

# HighlightedYank
# @see https://github.com/machakann/vim-highlightedyank
g:highlightedyank_highlight_duration = 250

# # TagBar
# # @see https://github.com/preservim/tagbar
# g:tagbar_sort = 0
# g:tagbar_compact = 1
# g:tagbar_autofocus = 1

# nmap <silent> <F8> :TagbarToggle<Enter>

# Fzf
# @see https://github.com/junegunn/fzf.vim
# @see https://jdhao.github.io/2018/11/05/fzf_install_use/#installation
# Jump to the existing buffer if is possible
g:fzf_buffers_jump = 1

# String in current file directory (by default: current cursor word)
nnoremap <silent> <Leader>I <ScriptCmd>Rgfzf(expand('<cword>'), 0, expand('%:h'))<Enter>
xnoremap <silent> <Leader>I <Esc><ScriptCmd>Rgfzf(expand('<cword>'), 0, expand('%:h'))<Enter>
# Files in current file directory
nnoremap <silent> <Leader>i :execute 'Files ' .. expand('%:p:h')<Enter>
xnoremap <silent> <Leader>i :<C-u>execute 'Files ' .. expand('%:p:h')<Enter>
# Files in current work directory
nnoremap <silent> <Leader>p :Files<Enter>
xnoremap <silent> <Leader>p :<C-u>Files<Enter>
# GFiles or Files in current work directory
nnoremap <silent> <expr> <Leader>o ":" .. (g:hasgit ? 'GFiles' : 'Files') .. "<Enter>"
xnoremap <silent> <expr> <Leader>o ":<C-u>" .. (g:hasgit ? 'GFiles' : 'Files') .. "<Enter>"
# Marks in current project directory
nnoremap <silent> <Leader>M :Marks<Enter>
xnoremap <silent> <Leader>M :<C-u>Marks<Enter>

# AsyncRun
# @see https://github.com/skywind3000/asyncrun.vim
# Skip message added in asyncrun (default: 0)
g:asyncrun_skip = 1
# Disable local errorformats (default: 1)
g:asyncrun_local = 0
# Action to run on stop job (default: empty)
g:asyncrun_exit = "silent call\ g:AsyncRunFinished()"
# Icon used in statusline (custom setup)
g:asyncrun_icon = ''

def AsyncRunCommand(command: string): void
    g:asyncrun_icon = '[▷]'
    g:asyncrun_hide = 0
    g:asyncrun_play = match(command, '-sound') >= 0
    g:qfcommand = command

    asyncrun#run(v:true, {
        raw: 1,
        strip: 1,
        silent: 1,
        once: 1,
    }, substitute(command, '-sound', '', 'g'))

    doautocmd <nomodeline> User UpdateStatusline
enddef

# @thanks https://github.com/lacygoill/wiki/blob/master/vim/vim9.md#when-can-i
def g:AsyncRunFinished(): void
    if g:asyncrun_code > 0
        g:asyncrun_icon = '[✗]'
        copen

        return
    endif

    g:asyncrun_icon = '[✓]'
    cclose
enddef

# Vim Tests
# https://github.com/vim-test/vim-test
g:test_strategy = get(g:, 'test_strategy', 'vimterminal')
g:test#echo_command = 0
g:test#custom_strategies = {'background': function('AsyncRunCommand')}
g:test#strategy = {
    'nearest': g:test_strategy,
    'file':    g:test_strategy,
    'suite':   g:test_strategy,
}

def TestStrategy(): void
    if index(['vimterminal'], g:test_strategy) >= 0
        g:test_strategy = 'background'
        g:asyncrun_icon = '[◎]'
    else
        g:test_strategy = 'vimterminal'
        g:asyncrun_icon = ''
    endif

    echo 'Strategy: ' .. g:test_strategy

    doautocmd <nomodeline> User AsyncRunPre
enddef

nnoremap <silent> <Leader>tt :execute ":TestNearest -strategy=" .. g:test_strategy<Enter>
nnoremap <silent> <Leader>tf :execute ":TestFile -strategy=" .. g:test_strategy<Enter>
nnoremap <silent> <Leader>ts :execute ":TestSuite " .. (g:test_strategy ==# 'background' ? '-sound ' : '') .. "-strategy=" .. g:test_strategy<Enter>
nnoremap <silent> <Leader>tl :TestLast<Enter>
nnoremap <silent> <Leader>tg :TestVisit<Enter>
nnoremap <silent> <Leader>tq <ScriptCmd>TestStrategy()<Enter>

# ALE
# @see https://github.com/dense-analysis/ale
g:ale_disable_lsp = 1
g:ale_linters_explicit = 1
g:ale_lint_on_enter = 1
g:ale_lint_on_text_changed = 'never'
g:ale_lint_on_insert_leave = 0
g:ale_set_balloons = 0
g:ale_set_loclist = 1
g:ale_set_quickfix = 0
g:ale_set_highlights = 1
g:ale_sign_error = 'E'
g:ale_sign_warning = 'W'
g:ale_echo_cursor = 0
g:ale_echo_msg_format = '%s'
g:ale_virtualtext_cursor = 'disabled'

def Diagnostics(): void
    PopupHide()

    if !exists('g:loaded_ale_dont_use_this_in_other_plugins_please') || &filetype !=# 'php'
        return
    endif

    var error = ale#statusline#FirstProblem(bufnr(), 'error')

    if !empty(error)
        silent PopupShow(printf(' %s:%d ', expand('%:p:t'), error.lnum), error.text)

        return
    endif

    var warning = ale#statusline#FirstProblem(bufnr(), 'warning')

    if !empty(warning)
        silent PopupShow(printf(' %s:%d ', expand('%:p:t'), warning.lnum), warning.text)

        return
    endif
enddef

def PopupShow(title: string, message: string)
    if !exists('w:winpopup') || index(popup_list(), w:winpopup.id) < 0
        var popupid = popup_create([], {
            pos: 'center',
            close: 'click',
            zindex: 300,
            padding: [1, 2, 1, 2],
            border: [],
            hidden: 1,
            highlight: 'WarningMsg',
        })

        w:winpopup = { 'id': popupid }
    endif

    popup_setoptions(w:winpopup.id, {
        title: title,
    })
    popup_settext(w:winpopup.id, message)
    popup_show(w:winpopup.id)

    PopupResize()
enddef

def PopupHide()
    if !exists('w:winpopup')
        return
    endif

    popup_hide(w:winpopup.id)

    unlet w:winpopup
enddef

def PopupResize()
    if !exists('w:winpopup')
        return
    endif

    var winwidth = winwidth(0)
    var winheight = winheight(0)

    var winpopuppos = popup_getpos(w:winpopup.id)

    if winwidth < 100 || winheight < 15 || !winpopuppos.visible
        PopupHide()

        return
    endif

    popup_move(w:winpopup.id, { pos: 'botright', col: winwidth, line: winheight })
enddef

# # CoC Completion
# # @see https://github.com/neoclide/coc.nvim
# g:coc_global_extensions = [
#     \ 'coc-clangd',
#     \ 'coc-phpactor',
# \]

    # \ 'coc-eslint',
    # \ 'coc-tslint',
    # \ 'coc-tsserver',
    # \ 'coc-vimlsp', <- Error: It starts a persist connection in node :(

    # \ 'coc-css',
    # \ 'coc-html',
    # \ 'coc-json',
    # \ 'coc-vetur',
    # \ 'coc-yaml',
    # \ 'coc-go',
    # \ 'coc-rust-analyzer',
    # \ 'coc-tailwindcss', Change class in HTML Files (blade included)

# # Use <Ctrl-Space> to trigger completion.
# inoremap <silent> <expr> <C-@> coc#refresh()

# Use <Tab> to select pum value or jump between placeholder in snippets
inoremap <silent> <expr> <Tab>
            \ UltiSnips#CanExpandSnippet() ? "\<C-r>=UltiSnips#ExpandSnippet()\<Enter>" :
            \ UltiSnips#CanJumpForwards() ? "\<C-r>=UltiSnips#JumpForwards()\<Enter>" :
            \ pumvisible() ? "\<C-n>" :
            \ "\<Tab>"

# In snippets with predefined values|content it uses Select Mode. WIP
snoremap <silent> <expr> <Tab>
            \ UltiSnips#CanExpandSnippet() ? "\<Esc>i\<C-r>=UltiSnips#ExpandSnippet()\<Enter>" :
            \ UltiSnips#CanJumpForwards() ? "\<Esc>i\<C-r>=UltiSnips#JumpForwards()\<Enter>" :
            \ pumvisible() ? "\<C-n>" :
            \ "\<Tab>"

# Make <S-Tab> for snippet navigation (and complete)
# Konsole change shortcut <S-Tab> to <C-S-Tab>
# @see https://vim.fandom.com/wiki/Smart_mapping_for_tab_completion
inoremap <silent> <expr> <Esc>[Z
            \ UltiSnips#CanJumpBackwards() ? "\<C-r>=UltiSnips#JumpBackwards()\<Enter>" :
            \ pumvisible() ? "\<C-p>" :
            \ "\<C-d>"

snoremap <silent> <expr> <Esc>[Z
            \ UltiSnips#CanJumpBackwards() ? "\<Esc>i\<C-r>=UltiSnips#JumpBackwards()\<Enter>" :
            \ pumvisible() ? "\<C-p>" :
            \ "\<C-d>"

# Make <Esc> close popup menu, keep pending (Conflict with <Esc>[Z aka <S-Tab>)
# Use <nowait> is required
inoremap <silent> <nowait> <expr> <Esc>
            \ pumvisible() ? "\<C-e>" :
            \ "\<Esc>"

# Make <Enter> auto-select the first completion item
inoremap <silent> <expr> <Enter>
            \ pumvisible() ? "\<C-r>=<SID>PumOnEnter()\<Enter>" :
            \ "\<Enter>"

def PumOnEnter(): string
    if len(v:completed_item) > 0
        # Keep and confirm
        return "\<C-y>"
    endif

    # Select and confirm
    return "\<C-n>\<C-y>"
enddef

# # Code navigation
# nmap <silent> gd <Plug>(coc-definition)
# nmap <silent> gy <Plug>(coc-implementation)
# nmap <silent> gr <Plug>(coc-references)

# Use K to show documentation in preview window
nnoremap <silent> K <ScriptCmd>ShowDocumentation()<Enter>

def ShowDocumentation()
    var word = expand('<cword>')

    if word ==# ''
        return
    endif

    if index(['vim', 'help'], &filetype) >= 0
        try
            silent execute 'help ' .. word
        catch
            echohl WarningMsg
            echo 'Not found: ' .. word
            echohl None
        endtry
    # elseif coc#rpc#ready()
    #     silent CocActionAsync('doHover')
    else
        # Don't add silent
        execute '!' .. &keywordprg .. ' ' .. word
    endif
enddef

# Remap <C-f> and <C-b> for scroll float windows/popups. (Used in long file definitions)
# if has('patch-8.2.0750') || has('nvim-0.4.0')
    # nnoremap <silent> <nowait> <expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    # nnoremap <silent> <nowait> <expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
# endif

# @see https://github.com/vim/vim/issues/4738
nnoremap <silent> <Plug>GoUrlRepeatable <ScriptCmd>GoUrl(expand('<cWORD>'))<Enter>
nmap <silent> gx <Plug>GoUrlRepeatable

def GoUrl(url: string): void
    var uri = url

    if match(uri, '[') >= 0
        uri = substitute(uri, '\v\[(.*)\]', '', '')
    endif

    if match(uri, '(') >= 0
        uri = substitute(uri, '\v.*\((.*)\)', '\1', 'ge')
    endif

    uri = substitute(uri, '"', '', 'ge')
    uri = substitute(uri, "'", '', 'ge')

    if match(uri, '\\') < 0
        # No escape yet
        uri = substitute(uri, '?', '\\?', 'ge')
        uri = substitute(uri, '&', '\\&', 'ge')
        uri = substitute(uri, ' ', '\\ ', 'ge')
    endif

    uri = trim(uri, ',')

    if uri !=# ''
        silent execute "!/usr/bin/firefox '" .. shellescape(uri, 1) .. "'"

        silent redraw!

        silent! repeat#set("\<Plug>GoUrlRepeatable")

        echo 'Opened:   ' .. uri
    endif
enddef

nnoremap <silent> gf <ScriptCmd>GoFile(expand('<cfile>'))<Enter>
nnoremap <silent> gF <ScriptCmd>GoLine()<Enter>

def GoFile(file: string): void
    var cdir = g:cwd
    var cext = expand('%:e')
    var ffile = file
    # Used in:     Symfony      Laravel
    var paths = ['templates', 'resources/views']

    try
        if cext ==# 'php' && match(ffile, '\.twig$') <= 0
            ffile = substitute(ffile, '\.', '/', 'g') .. '.blade.php'
        endif

        for path in paths
            ffile = join([cdir, path, ffile], '/')

            if filereadable(ffile)
                silent execute 'edit ' .. fnameescape(ffile)

                return
            endif
        endfor

        # Fallback. Use normal! <Bang>, it skip custom mappings
        normal! gf
    catch
        echohl WarningMsg
        echo Exception()
        echohl None
    endtry

    return
enddef

# @see https://vim.fandom.com/wiki/Faster_loading_of_large_files
augroup LargeFile
    autocmd!

    autocmd BufWinEnter * CheckLarge_file(expand('<afile>'))
augroup END

def CheckLarge_file(file: string): void
    if file ==# '' || index(['jpg', 'jpeg', 'png', 'gif', 'svg', 'pdf'], expand(file .. ':t')) >= 0
        return
    endif

    # File is large from 2MB
    var maxsize = 1024 * 1024 * 2
    var fsize = getfsize(file)
    var hfsize = fsize / 1024 / 1024
    var hmaxsize = maxsize / 1024 / 1024

    if fsize > maxsize || fsize == -2
        syntax off
        filetype off
        # No syntax highlighting event
        # set eventignore+=FileType  # Comment because on change filetype in same session has weird behaviour
        setlocal noloadplugins
        setlocal noundofile
        setlocal noswapfile
        setlocal nocursorline
        setlocal nocursorcolumn
        setlocal colorcolumn=0
        setlocal norelativenumber
        setlocal bufhidden=unload
        # setlocal buftype=nowrite # No allowed changes in same file, it's annoyoning!
        setlocal foldmethod=manual
        setlocal undolevels=-1

        echohl WarningMsg
        echomsg 'The file has ' .. hfsize .. ' MB (> ' .. hmaxsize .. ' MB), so some options were changed.'
        echohl None
    elseif !exists('g:syntax_on') && bufname('%') !=# ''
        filetype detect
        syntax enable
        Postcolorscheme()

        echomsg 'The file has ' .. hfsize .. ' MB (<= ' .. hmaxsize .. ' MB), options were restored.'
    endif
enddef

# Surround
# @see https://github.com/tpope/vim-surround
# b = between
g:surround_indent = 1

nmap <silent> <leader>b ysiw
xmap <silent> <leader>b S

# # CTags
# # @see https://github.com/vim-scripts/autotags
# g:autotags_no_global = 0
# g:autotags_cscope_file_extensions = '.php .h .c'
# g:autotags_ctags_global_include = ''
# g:autotags_ctags_opts = '--exclude="\.git" --exclude="\.idea" --exclude="\.vscode" --exclude=bin --exclude=var --exclude="*Test.php" --exclude="*phpunit*" --exclude=node_modules --exclude=storage --exclude=database --tag-relative=yes --c++-kinds=+p --regex-php="/^[   ]*trait[        ]+([a-z0_9_]+)/\1/t,traits/i" --php-kinds=+cfi-vj --fields=+aimlS --extra=+q'

# nnoremap <C-]> g<C-]>

# Fugitive
# @see https://github.com/tpope/vim-fugitive
g:fugitive_no_maps = 1

def GitAlias(): list<list<string>>
    var aliases = []
    # Ignore some alias with "special" chars like: pipe, ampersand
    var lines = systemlist(g:filterprg .. ' "^alias(.*)=\"git " ~/.bash_aliases | ' .. g:filterprg .. ' --invert-match "log|blame|\||&" | sed "s/alias \|\"//gi"')

    for line in lines
        var shortcut = ''
        var command = ''

        try
            [shortcut, command] = split(substitute(line, '=', '@@==@@', ''), '@@==@@')
        catch
            continue
        endtry

        aliases += [[trim(shortcut), trim(substitute(substitute(command, 'git ', 'Git ', ''), ' -w', '', ''))]]
    endfor

    return aliases
enddef

nnoremap <silent> <Leader>ga :Git add % <Bar> echo 'Added:    ' .. expand('%')<Enter>

# Resolve conflicts
# @see https://vim.fandom.com/wiki/A_better_Vimdiff_Git_mergetool
# @see https://gist.github.com/karenyyng/f19ff75c60f18b4b8149
# Using path in vim-fugitive:
#   .   -> Ready to command
#   =   -> [=]toggle [>]show|[<]hide inline changes
#   -   -> [-]toggle [u]n|[s]tage file
#   U   -> [U]nstage everything
#   I   -> [I]include [P]atch from file
#   (   -> Preview file
#   )   -> Next file
#   dd  -> [d]iff view (in horizontal)
#   dq  -> [d]iff [q]uit
#   [c  -> Preview change (not conflict!)
#   ]c  -> Next change (not conflict!)
#   \r  -> Go to file
nnoremap <silent> <Leader>hh /\v[<\|>\|=]{7}<Enter>

# if &diff <-- fails with diff mode opens from vim-fugitive
    nnoremap <silent> <Leader>gf :diffget //2<Enter>
    nnoremap <silent> <Leader>gj :diffget //3<Enter>
    nnoremap <silent> <Leader>gg :Gwrite <Bar> edit %<Enter>
# endif

# I don't want to learn (or write) new aliases
cnoreabbrev <expr> git (getcmdtype() ==# ':' && getcmdline() ==# 'git') ? 'Git' : 'git'

for [shortcut, command] in GitAlias() + [['gh', 'Git blame'], ['gst', 'Git']]
    execute "cnoreabbrev <expr> " .. shortcut .. " (getcmdtype() ==# ':' && getcmdline() ==# '" .. shortcut .. "') ? '" .. command .. "' : '" .. shortcut .. "'"
endfor

# GitGutter
# @see https://github.com/airblade/vim-gitgutter
# g:gitgutter_enabled = 1 (default)
# g:gitgutter_eager = 1 (¿?)
# g:gitgutter_realtime = 0 (¿?)
g:gitgutter_map_keys = 0
g:gitgutter_max_signs = 500
# g:gitgutter_sign_priority = 100000
# g:gitgutter_sign_allow_clobber = 0
g:gitgutter_preview_win_floating = 1
g:gitgutter_close_preview_on_escape = 1
g:gitgutter_show_msg_on_hunk_jumping = 0
g:gitgutter_grep = g:filterprg

nmap <silent> <expr> <Leader>k &diff ? "[czzzv" : ":GitGutterPrevHunk<Enter>zzzv"
nmap <silent> <expr> <Leader>j &diff ? "]czzzv" : ":GitGutterNextHunk<Enter>zzzv"
nmap <silent> <Leader>mm <Plug>(GitGutterStageHunk)
nmap <silent> <Leader>hu <Plug>(GitGutterUndoHunk)
nmap <silent> <Leader>hp <Plug>(GitGutterPreviewHunk)

# DadBod
# @see https://github.com/tpope/vim-dadbod
def Db(): string
    var url = Getenv('DATABASE_URL')

    if url ==# ''
        var conn = Getenv('DB_CONNECTION')
        var host = Getenv('DB_HOST')
        var port = Getenv('DB_PORT')
        var data = Getenv('DB_DATABASE')
        var user = Getenv('DB_USERNAME')
        var pass = Getenv('DB_PASSWORD')
        url = join([conn, '://', user, ':', db#url#encode(pass), '@', host, '/', data], '')
    endif

    if url ==# '://:@/'
        return ''
    endif

    return url
enddef

def Query(range: number, interactive: bool, ...command: list<string>): void
    var url = Db()
    var selection = GetSelection(range, interactive, command)

    if url ==# '' || (selection ==# '' && !interactive)
        echo 'Nothing to do.'

        return
    endif

    # Don't add silent
    execute join(['DB', url, selection], ' ')
enddef

command! -nargs=? -range -bang Q Query(<range>, <bang>0, <f-args>)

def Run(range: number, interactive: bool, ...command: list<string>): number
    var selection = GetSelection(range, interactive, command)

    if selection ==# ''
        echo 'Nothing to do.'

        return 0
    endif

    var executable = ''
    var ignorechars = []
    var filetype = &filetype
    var runner = 0

    if filetype ==# ''
        runner = confirm('Select runner:', "&bash\n&php", 0, 'Q')
    endif

    if runner ==# 1 || index(['markdown', 'sh'], filetype) >= 0
        executable = 'bash -c "%s"'
        ignorechars = ["'", '\']
    elseif runner ==# 2 ||  index(['php'], filetype) >= 0
        # requires end with semicolon (;)
        executable = 'php --run "%s"'
        ignorechars = ["'"]

        if filereadable('artisan')
            # dump() doesn't allow multiple sentences split by semicolon (;) :(
            executable = 'echo "%s" | php artisan tinker --no-interaction'
        endif
    elseif runner ==# 0
        echo 'Run canceled.'

        return 0
    else
        echohl ErrorMsg
        echo 'Run ' .. filetype .. ' unsupported.'
        echohl None

        return 2
    endif

    var run = printf(executable, Escape(selection, ignorechars))
    var result = system(run)

    if v:shell_error > 0                                        # <-- $? @see https://www.gnu.org/software/bash/manual/bash.html
        setreg('+', run)

        echohl WarningMsg
        echo len(result) ? result : 'Return:   ' .. v:shell_error
        echohl None

        return 1
    endif

    setreg('+', trim(result))

    echo len(getreg('+')) > 0 ? getreg('+') : selection

    return 0
enddef

command! -nargs=? -range -bang R Run(<range>, <bang>0, <f-args>)

def GetSelection(range: number, interactive: bool, args: list<string>): string
    var selection = ''

    if len(args) > 0
        selection = join(args, ' ')
    elseif range == 2
        # @see https://vi.stackexchange.com/a/11028
        var [lnum1, col1] = getpos("'<")[1 : 2]
        var [lnum2, col2] = getpos("'>")[1 : 2]

        var lines = getline(lnum1, lnum2)

        if len(lines) > 0
            lines[-1] = lines[-1][: col2 - (&selection ==# 'inclusive' ? 1 : 2)]
            lines[0] = lines[0][col1 - 1 :]

            selection = join(lines, ' ')
        endif
    elseif !interactive
        selection = trim(getline('.'))
    endif

    return selection
enddef

# # Tagalong
# # @see https://github.com/AndrewRadev/tagalong.vim
# g:tagalong_filetypes = ['html', 'xml']

nnoremap <silent> <Plug>SplitRepeatable <ScriptCmd>Split()<Enter>
nmap <silent> gS <Plug>SplitRepeatable

# @see https://github.com/AndrewRadev/splitjoin.vim
def Split(): void
    var saved_search_register = getreg('/')
    var saved_unnamed_register = getreg('@')
    var command_string = ''
    var line = getline('.')

    # Is ternary?
    if match(line, ' ? ') > 0
                \ && match(line, ' : ') > 0
                # \ && (match(line, ';') > 0 || match(line, ',') > 0) VimL not need this chars
        silent execute "normal! _/ ? \ri\r\e/ : \r\"_xi\r\e"
    # Is array?
    elseif match(line, '[') > 0
                \ && match(line, ',') > 0
                \ && match(line, ']') > 0
                \ && match(line, ';') > 0
                \ && match(line, '[') + 1 != match(line, ']')
        silent execute 'normal! _f[vi["zy'

        var arguments_list = split(getreg('z'), ',')

        for argument in arguments_list
            command_string = command_string .. "\t" .. trim(argument) .. ",\r"
        endfor

        silent execute "normal! \"_di[i\r" .. command_string .. "\e"
    # Are arguments?
    elseif match(line, '(') > 0
                \ && match(line, ',') > 0
                \ && match(line, ')') > 0
        silent execute 'normal! _f(vi("zy'

        var arguments_list = split(getreg('z'), ',')

        for argument in arguments_list
            command_string = command_string .. "\t" .. trim(argument) .. (len(arguments_list) > 1 ? ',' : '') .. "\r"
            silent remove(arguments_list, 0)
        endfor

        silent execute "normal! \"_di(i\r" .. command_string .. "\e"

        silent execute 'normal! jlv"zy'

        if getreg('z') ==# '{'
            silent execute 'normal! kJ'
        endif
    # Is comma list?
    elseif match(line, ',') > 0
        var arguments_list = split(line, ',')

        for argument in arguments_list
            command_string = command_string .. trim(argument) .. (len(arguments_list) > 1 ? ',' : '') .. "\r"
            silent remove(arguments_list, 0)
        endfor

        silent execute "normal! \"_ddi" .. command_string .. "\e"
    # Is chaining methods?
    elseif match(line, '->') > 0
        var arguments_list = split(line, '->')

        if len(arguments_list) <= 2 # Once ocurrence
            echo 'Nothing to do.'

            return
        endif

        var counter = 1

        for argument in arguments_list
            if counter < 2
                counter = counter + 1

                command_string = command_string .. trim(argument)

                continue
            else
                command_string = command_string .. (len(command_string) > 0 ? '->' : '') .. trim(argument) .. (len(arguments_list) > 1 ? "\r" : '')
            endif

            silent remove(arguments_list, 0)
        endfor

        silent execute "normal! \"_ddO" .. command_string .. "\e\"_dd=="
    else
        echo 'Nothing to do.'
    endif

    setreg('@', saved_unnamed_register)
    setreg('/', saved_search_register)

    silent! repeat#set("\<Plug>SplitRepeatable")
enddef

def Exception(): string
    return join(split(v:exception, ' ')[1 : -1], ' ')
enddef

# Open notes in Normal|Select|Operator Mode
nmap <silent> <F9> <ScriptCmd>Notes()<Enter>

def Notes(): void
    var matches = []
    var header = '>> ' .. strftime('%A, %d of %B %Y')
    var filename = expand('~/working/notes/notes_' .. strftime('%Y%m') .. '.md')
    var lsearch = getreg('/')

    if bufname('%') !=# '' && split(bufname('%'), '/')[-1] ==# split(filename, '/')[-1]
        silent update!
    else
        silent execute 'edit ' .. fnameescape(filename)
    endif

    try
        setreg('z', [])
        silent execute ':silent global/\V' .. header .. "/y Z"
    catch /^Vim\%((\a\+)\)\=:E486/
        # @see https://vimhelp.org/pattern.txt.html#E486
    endtry

    if !filereadable(filename) || len(getreg('z')) == 0
        silent execute "normal! Go\e<<i\r" .. header .. "\r\e"
    else
        silent execute "normal! Go\e"
    endif

    silent execute "normal! Gzto== " .. strftime('%H:%M') .. " ==\r- \e"

    silent setreg('/', lsearch)
    silent histdel('/', -1)
enddef

augroup AutoCommands
    autocmd!

    # Reload after save and run PlugInstall if there are missing plugins
    autocmd BufWritePost .vimrc,.vimrc9 ++nested source $MYVIMRC
                \ | if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
                \ |     PlugInstall
                \ | endif

    # Customization
    autocmd BufRead,BufNewFile .env.* setfiletype sh
    autocmd BufRead,BufNewFile *.tphp setfiletype php
    autocmd BufRead,BufNewFile .php_cs* setfiletype php
    autocmd BufRead,BufNewFile *.conf setfiletype apache
    autocmd BufRead,BufNewFile *.json.*,*.lock setfiletype json
    autocmd BufRead,BufNewFile *.twig setfiletype html | setlocal commentstring=\{#\ %s\ #\}
    autocmd BufRead,BufNewFile *.blade.php setfiletype html | setlocal commentstring=\{\{--\ %s\ --\}\}
    autocmd BufRead,BufNewFile *.vue setlocal commentstring=<!--\ %s\ -->
    autocmd BufRead,BufNewFile */i3/config setfiletype i3config | setlocal commentstring=#\ %s
    autocmd BufRead,BufNewFile /etc/hosts setlocal commentstring=#\ %s
    autocmd BufRead,BufNewFile */{log,logs}/* setlocal filetype=log
    autocmd BufRead,BufNewFile *.log setlocal filetype=log
    autocmd BufRead,BufNewFile *.{csv,tsv} setlocal filetype=csv list
    autocmd BufRead,BufNewFile *.tsv setlocal noexpandtab tabstop=4
    autocmd BufRead,BufNewFile .gitignore setfiletype gitignore
    # autocmd BufRead,BufNewFile *.vpm setfiletype vpm

    autocmd FileType sql setlocal commentstring=--\ %s
    autocmd FileType sql b:db = Db() | setlocal omnifunc=vim_dadbod_completion#omni
    autocmd FileType sql inoremap <silent> <expr> <buffer><C-n>
                \ match(getline('.')[col('.') - 2], '\W') >= 0 && match(getline('.')[col('.') - 2], '\.') < 0 ? "\<C-x>\<C-n>" :
                \ pumvisible() ?  "\<C-n>" :
                \ "\<C-x>\<C-o>"
    autocmd FileType apache setlocal commentstring=#\ %s
    autocmd FileType crontab setlocal commentstring=#\ %s
    autocmd FileType html,xml setlocal matchpairs+=<:>
    autocmd FileType php setlocal commentstring=//\ %s
    autocmd FileType php,c setlocal matchpairs-=<:>
    autocmd FileType yaml,json setlocal softtabstop=2 shiftwidth=2
    autocmd FileType c,cpp setlocal path+=/usr/include include&
    autocmd FileType vim setlocal keywordprg=:help
    autocmd FileType git setlocal foldmethod=syntax foldlevel=1
    autocmd FileType gitcommit setlocal foldmethod=syntax foldlevel=1 textwidth=72
    # autocmd FileType markdown,log,csv b:coc_suggest_disable = 1

    # autocmd FileType html,css,javascript,vue EmmetInstall

    # @see https://github.com/tpope/vim-vinegar/issues/13#issuecomment-47133890
    autocmd FileType netrw setlocal bufhidden=delete
    # Weird behaviour using this mapping
    autocmd FileType netrw map <silent> <buffer><C-l> <Nop>

    # Return to last edit position when opening files
    autocmd BufReadPost *
                \ if &filetype !=# '\%(^git\%(config\)\@!\|commit\)' && line("'\"") > 0 && line("'\"") <= line('$') |
                \   silent execute "normal! g`\"" |
                \ endif

    # Hide signcolumn in Terminal Mode
    # Esc: Escape from Terminal Mode to Normal Mode (No applied fzf buffers)
    autocmd TerminalWinOpen * if &buftype ==# 'terminal'
                | setlocal bufhidden=wipe
                | setlocal signcolumn=no
                | setlocal colorcolumn=0
                | setlocal nolist
                | if expand('%')[-3 :] !=? '!sh'
                | tnoremap <silent> <buffer><Esc> <C-\><C-n><Enter>
                | endif
                | endif

    # Ominifunctions
    autocmd FileType c setlocal omnifunc=ccomplete#CompleteCpp
    autocmd FileType php setlocal omnifunc=phpactor#Complete
    autocmd FileType php setlocal completefunc=phpactor#Complete
    # autocmd FileType php setlocal omnifunc=phpcomplete#CompletePHP
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS

    # VPM: Vim Presentation Mode
    # autocmd FileType vpm nnoremap <silent> <buffer><Left> :silent bprevious<Enter> :redraw!<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer><Right> :silent bnext<Enter> :redraw!<Enter>
    # TOIlet
    # autocmd FileType vpm nnoremap <silent> <buffer>.f :.!toi-w 200 -f small<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.F :.!toi-w 200 -f standard<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.k :.!toi-w 200 -f small -k<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.K :.!toi-w 200 -f standard -k<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.w :.!toi-w 200 -f small -W<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.W :.!toi-w 200 -f standard -W<Enter>
    # autocmd FileType vpm nnoremap <silent> <buffer>.b :.!toi-w 200 -f term -F border<Enter>

    # PHP Customization
    autocmd FileType php nnoremap <silent> <buffer><Leader>uu <ScriptCmd>phpactor#UseAdd()<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Plug>AddIncompleteMarkRepeatable <ScriptCmd>AppendChar('i')<Enter>
    autocmd FileType php nmap     <silent> <buffer><i <Plug>AddIncompleteMarkRepeatable
    autocmd FileType php nnoremap <silent> <buffer><Plug>DropIncompleteMarkRepeatable <ScriptCmd>AppendChar('I')<Enter>
    autocmd FileType php nmap     <silent> <buffer>>i <Plug>DropIncompleteMarkRepeatable
    autocmd FileType php nnoremap <silent> <buffer>H F$
    autocmd FileType php nnoremap <silent> <buffer>L f$

    # PHP Testing
    autocmd FileType php g:test#php#phpunit#options = { 'all': '--no-coverage --stop-on-failure' }

    autocmd FileType php nnoremap <silent> <buffer><Leader>tT :execute ":TestNearest --testdox -vvv -strategy=vimterminal"<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>tF :execute ":TestFile --testdox -vvv -strategy=vimterminal"<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>tS :execute ":TestSuite --testdox -vvv -strategy=vimterminal"<Enter>

    # PHP Linter
    autocmd FileType php g:ale_linters = {'php': ['php', 'phpmd']}
    autocmd FileType php g:ale_php_phpmd_ruleset = 'unusedcode'

    # PHP Refactor
    # @see https://github.com/phpactor/phpactor
    # autocmd FileType php nnoremap <silent> <buffer><Leader>rnc <ScriptCmd>phpactor#ClassNew()<Enter>
    # autocmd FileType php nnoremap <silent> <buffer><Leader>rxc <ScriptCmd>phpactor#ClassExpand()<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>ruu <ScriptCmd>phpactor#ImportMissingClasses()<Enter>

    autocmd FileType php nnoremap <silent> <buffer><Leader>rmf <ScriptCmd>phpactor#MoveFile()<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rcf <ScriptCmd>phpactor#CopyFile()<Enter>

    autocmd FileType php nnoremap <silent> <buffer><Leader>ric <ScriptCmd>Phpactor('implement_contracts')<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rap <ScriptCmd>Phpactor('add_missing_properties')<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rcc <ScriptCmd>Phpactor('complete_constructor')<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>run <ScriptCmd>Phpactor('fix_namespace_class_name')<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rfg <ScriptCmd>setreg('z', "orfg\t\e/    {\rh") <Bar> execute "normal! @z"<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rfs <ScriptCmd>setreg('z', "orfs\t\e/    {\rh") <Bar> execute "normal! @z"<Enter>

    autocmd FileType php nnoremap <silent> <buffer><Leader>rci <ScriptCmd>phpactor#ClassInflect()<Enter>
    autocmd FileType php xnoremap <silent> <buffer><Leader>rem <ScriptCmd><C-u>phpactor#ExtractMethod()<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>rec <ScriptCmd>phpactor#ExtractConstant()<Enter>
    autocmd FileType php xnoremap <silent> <buffer><Leader>ree <ScriptCmd><C-u>phpactor#ExtractExpression(v:true)<Enter>
    autocmd FileType php nnoremap <silent> <buffer><Leader>R   <ScriptCmd>phpactor#ContextMenu()<Enter>

    autocmd FileType php nmap <silent> <buffer>gd <ScriptCmd>phpactor#GotoDefinition()<Enter>
    # autocmd FileType php nmap <silent> <buffer>gy <ScriptCmd>phpactor#GotoImplementations()<Enter>
    # autocmd FileType php nmap <silent> <buffer>gr <ScriptCmd>phpactor#FindReferences()<Enter>

    def Phpactor(transformer: string): void
        silent update!

        var result = system(g:phpactorbinpath .. ' class:transform ' .. expand('%') .. ' --transform="' .. transformer .. '"')

        silent edit!
    enddef

    # Go parent (extends) or implements (interface) file from 'any' position
    autocmd FileType php nmap <silent> <buffer>gX <ScriptCmd>GoParent()<Enter>

    def GoParent(): void
        var pattern = ' extends \| implements '

        var [lnum, col] = searchpos(pattern, 'n')

        if lnum > 0 && col > 0
            silent cursor(lnum, col)
            # Not use normal! <Bang>, it needs gd mapping
            silent! execute "keepjumps normal 2Wgd"
        else
            echo 'Nothing to do.'
        endif
    enddef

    # Search current file(Y) or function(y) implementations
    autocmd FileType php nmap <silent> <buffer>gY <ScriptCmd>GetImplementations('file')<Enter>
    autocmd FileType php nmap <silent> <buffer>gy <ScriptCmd>GetImplementations('word')<Enter>

    def GetImplementations(type: string): void
        # Searching Name, then
        # Files like:
        #   class Name
        #   trait Name
        #   interface Name
        #   class Name extends Parent
        # but doesn't like:
        #   interface NameLarge
        #   interface LargeName
        # Call likes: as Files and:
        #   function name(
        #   function Name(
        # but doesn't likes:
        #   function nameLarge(
        var string = type ==# 'file'
                    \ ? expand('%:t:r')
                    \ : expand('<cword>')

        if string ==# ''
            echo 'Nothing to do.'

            return
        endif

        # @see https://regex101.com/r/Py4xXG/1
        var pattern = type ==# 'file'
                    \ ? '(class|trait|interface) \b' .. string .. '\b(\s?\w*)'
                    \ : '(class|trait|interface|function) \b' .. string .. '\b(\(?|\s?)'

        silent execute "Grep --glob '*.php' --ignore-case '" .. RGEscape(pattern) .. "'"
    enddef

    # Search current file(R) or funtion(r) references
    autocmd FileType php nmap <silent> <buffer>gR <ScriptCmd>GetReferences('file')<Enter>
    autocmd FileType php nmap <silent> <buffer>gr <ScriptCmd>GetReferences('word')<Enter>

    def GetReferences(type: string): void
        # Files like:
        #   Name::
        #   Name(
        # Call likes: as Files and:
        #   name(
        #   ->name(
        #   ::name(
        #   new name(
        # but doesn't like:
        #   _name(
        #   -name(
        var string = type ==# 'file'
                    \ ? expand('%:t:r')
                    \ : expand('<cword>')

        if string ==# ''
            echo 'Nothing to do.'

            return
        endif

        var pattern = type ==# 'file'
                    \ ? '\b' .. string .. '\b(::|\(|;)'
                    \ : '(->|::|new )?[^_-]\b' .. string .. '\b(\(|;)'

        silent execute "Grep --glob '*.php' --ignore-case '" .. RGEscape(pattern) .. "'"
    enddef

    # PHP Fixer
    autocmd FileType php nnoremap <silent> <buffer><F1> <ScriptCmd>Phpfixer()<Enter>

    def Phpfixer(): void
        if bufname('%') ==# ''
            echohl WarningMsg
            echo 'Save file first!.'
            echohl None

            return
        endif

        # Setup default
        var fixertype = 'global'
        var fixerpath = 'php-cs-fixer'
        var fixerversion = 'unknow'
        var configpath = '/var/www/html/freddiegar/services/'

        if executable('vendor/bin/php-cs-fixer')
            fixertype = 'local'
            fixerpath = 'vendor/bin/php-cs-fixer'
        endif

        if !executable(fixerpath)
            echohl WarningMsg
            echo 'Fixer ' .. fixertype .. ' ' .. fixerversion .. ' not found.'
            echohl None

            return
        endif

        fixerversion = system(fixerpath .. " --version 2>/dev/null | cut -d ' ' -f 4 | cut -d '.' -f 1 | tr -d '\n'")

        var configversion = fixerversion
        var configfile = configpath .. (configversion ==# '2' ? '.php_cs' : '.php-cs-fixer.php')

        if filereadable(expand('.php_cs'))
            # Setup v2
            configversion = '2'
            configfile = '.php_cs'
        elseif filereadable(expand('.php-cs-fixer.php'))
            # Setup v3
            configversion = '3'
            configfile = '.php-cs-fixer.php'
        endif

        if fixerversion !=# configversion
            echohl WarningMsg
            echo 'Fixer ' .. fixertype .. ' v' .. fixerversion .. ' config file not found.'
            echohl None

            return
        endif

        silent update!

        var result = system(fixerpath .. ' fix ' .. expand('%') .. ' --config="' .. configfile .. '"')

        silent edit!

        echo 'Fixer ' .. fixertype .. ' v' .. fixerversion .. ' applied.'
    enddef

    autocmd FileType vim-plug nnoremap <silent> <buffer><Leader>gd <ScriptCmd>GoDocs(substitute(expand('<cWORD>'), '["\|:]', '', 'g'))<Enter>

    autocmd FileType json nnoremap <silent> <buffer><F1> <ScriptCmd>Jsonfixer()<Enter>
    autocmd FileType json nnoremap <silent> <buffer><Leader>gd <ScriptCmd>GoDocs(substitute(expand('<cWORD>'), '["\|:]', '', 'g'))<Enter>
    autocmd FileType json nnoremap <silent> <buffer><Leader>gi <ScriptCmd>echo 'Version:  ' .. Composer('info', substitute(expand('<cWORD>'), '["\|:]', '', 'g'))<Enter>

    def Jsonfixer(): void
        if bufname('%') !=# ''
            silent update!
        endif

        silent execute '%!python3 -m json.tool'
    enddef

    def Composer(command: string, dependency: string): string
        var version = system('composer ' .. command .. ' 2>/dev/null | ' .. g:filterprg .. ' "' .. dependency .. '" | sed "s#\s\+# #g" | cut -d " " -f 2 | tr -d "\n"')

        return len(version) > 0 ? version : 'None'
    enddef

    # Custom register by filetype
    # Diff [t]ime operation
    autocmd BufRead .vimrc @t = "\"ayiWj\"byiWj ciW=100-((b*100)/a)\r\e"

    # Open files with external application
    autocmd BufEnter *.jpg,*.jpeg,*.png,*.gif,*.svg GoUrl(expand('<afile>')) | bwipeout
    autocmd BufEnter *.pdf GoUrl(expand('<afile>')) | bwipeout

    # @see :help :function
    # @see :help function-argument
    # @see http://www.adp-gmbh.ch/vim/user_commands.html
    def Rgfzf(fzfquery: string, fullscreen: number, scope = '', isregex = 0): void
        var directory = isdirectory(scope) ? scope : ''
        var filter_type = isregex ? '--no-fixed-strings' : '--fixed-strings'
        var finder_command = "rg --glob '!{*.log,*-lock.json,*.lock}' --column --line-number --no-heading --color=always " .. filter_type .. " -- %s " .. directory .. ' || true'
        var initial_command = printf(finder_command, shellescape(fzfquery))
        var reload_command = printf(finder_command, '{q}')
        var options = {'options': ['--phony', '--query', fzfquery, '--bind', 'change:reload:' .. reload_command]}

        silent fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(options), fullscreen)
    enddef

    # Git blame
    # @thanks https://gist.github.com/romainl/5b827f4aafa7ee29bdc70282ecc31640
    command! -range GB GetBlame(<line1>, <line2>)

    def GetBlame(line1: number, line2: number): void
        var result = systemlist('git -C ' .. shellescape(expand('%:p:h')) .. ' blame -L ' .. line1 .. ',' .. line2 .. ' ' .. expand('%:t'))

        var commit = len(result) > 0 ? split(result[0])[0] : '0000000000'

        if commit !=# '0000000000'
            setreg('+', commit)
        endif

        echo join(result, "\n")
    enddef

    def Envfile(): string
        var envfile = ''
        var envfiles = [
                \ '.env.local',
                \ '.env',
              \ ]

        for file in envfiles
            if filereadable(expand(file))
                envfile = file

                break
            endif
        endfor

        return envfile
    enddef

    def Envload(force: number, file = ''): void
        var message = ''
        var envfile = len(file) ==# 0 ? Envfile() : file

        if envfile ==# ''
            return
        endif

        var ftime = getftime(fnamemodify(envfile, ':p'))

        if ftime < 0
            return
        endif

        var [ctime, lines] = get(g:cache, envfile, [-2, []])

        if ftime != ctime || force
            lines = systemlist(g:filterprg .. ' "^(DB_|DATABASE_URL)" ' .. envfile .. ' | sed "s/^D/VIM_D/"')
            g:cache[envfile] = [ftime, lines]

            message = 'Loaded ' .. envfile .. ' vars.'
        endif

        for line in lines
            try
                var [name, value] = split(substitute(line, '=', '@@==@@', ''), '@@==@@')

                g:env[name] = shellescape(value)

                silent execute '$' .. name ' = ' .. shellescape(value)
            catch
                continue
            endtry
        endfor

        # aka :verbose Dotenv
        if &verbose
            for name in sort(keys(g:env))
                Envecho(name, g:env[name])
            endfor
        endif

        if message !=# ''
            echomsg message
        endif
    enddef

    def Envecho(name: string, value: string): void
        echohl VimLet
        echon ''
        echohl vimEnvvar
        echon '$' .. name
        echohl vimOper
        echon ' = '
        echohl vimString
        echon value
        echohl None
        echon "\n"
    enddef

    def Getenv(name: string, default = ''): string
        try
            var prefix = 'VIM_'
            var key = prefix .. substitute(name, '^\$' .. prefix, '', '')

            return exists('$' .. key) ? eval('$' .. key) : get(g:env, key, default)
        catch
            return ''
        endtry
    enddef

    command! -bar -bang -nargs=? -complete=file Dotenv Envload(<bang>0, <f-args>)

    def Viminfo(): void
        if !g:hasgit
            &viminfofile = 'NONE'

            return
        endif

        g:infofile = '.git/.viminfo'
        &viminfofile = g:infofile

        if !filereadable(g:infofile)
            g:infofile = ''

            return
        endif

        silent execute 'rviminfo ' .. g:infofile
    enddef

    def Sessionload(): void
        var message = ''
        var envfile = Envfile()
        var session = split(g:session_file, '/')[-1]

        if !argc() && g:hasgit && empty(v:this_session) && filereadable(g:session_file) && !&modified
            silent execute 'source ' .. g:session_file

            message = 'Loaded ' .. session .. '##ENV####INF##.'
        elseif !argc() && g:hasgit
            message = 'Created ' .. session .. '##ENV####INF##.'
        endif

        if envfile !=# ''
            silent execute 'Dotenv ' .. envfile

            message = message ==# '' ? 'Loaded ' .. envfile .. ' vars.' : substitute(message, '##ENV##', ' with ' .. envfile, '')
        endif

        if g:infofile !=# ''
            message = message ==# '' ? 'Loaded ' .. g:infofile .. ' setup.' : substitute(message, '##INF##', ' and ' .. g:infofile, '')
        endif

        if message !=# ''
            message = substitute(message, '##ENV##', '', '')
            message = substitute(message, '##INF##', '', '')

            echomsg message
        endif
    enddef

    def Sessionsavepre(): void
        var index = 0

        while index < argc()
            var larg = argv(index)

            if index(['.git/COMMIT_EDITMSG', '.git/MERGE_MSG'], larg) >= 0
                        \ || buflisted(larg) == 0
                        \ || getbufvar(larg, '&filetype') ==# 'netrw'
                        \ || isdirectory(larg)
                silent execute 'argdelete! ' .. fnameescape(larg)
            endif

            index = index + 1
        endwhile

        return
    enddef

    def Sessionsave(): void
        if g:hasgit && !(expand('%:h:p') ==# '/tmp' && &filetype ==# 'zsh')
            Sessionsavepre()

            silent execute 'mksession! ' .. g:session_file

            echomsg 'Saved ' .. split(g:session_file, '/')[-1]

            v:this_session = ''
        endif
    enddef

    def Poststart(): void
        # @see https://stackoverflow.com/questions/6076592/vim-set-formatoptions-being-lost#8748154
        set formatoptions=                                      # (default: croql)
        set formatoptions+=c                                    # Auto-wrap [c]omments using textwidth
        set formatoptions+=r                                    # Insert automatically comment char after Ente[r]
        set formatoptions+=q                                    # Allow formatting comments whit "gq"
        set formatoptions+=l                                    # Don't broken [l]ong lines comments
        set formatoptions+=j                                    # Remove comment string in [j]oining comments
        set formatoptions+=n                                    # Detect list of [n]umbers (require autoindent enable)
    enddef

    # [t]railing spaces in end of line
    # [e]nd of file lines
    # [d]uplicate blank lines
    # [v]erbose
    def Cleanup(include: string): void
        if &diff
            echohl WarningMsg
            echo 'Nothing to clean-up in diff mode.'
            echohl None

            return
        endif

        var options = split(include, '\zs')
        var ccursor = getpos('.')
        var lsearch = getreg('/')
        var cleanup = []

        if index(options, 't') >= 0
            silent! :%s/\s\+$//e

            silent add(cleanup, 'trailing spaces')
        endif

        if index(options, 'e') >= 0
            silent! :%s/\n\+\%$//e

            silent add(cleanup, 'end of file lines')
        endif

        if index(options, 'd') >= 0
            # @see https://vi.stackexchange.com/questions/1920/how-does-g-j-reduce-multiple-blank-lines-to-a-single-blank-work-in-vi
            silent! :g/^$/,/./-j

            silent add(cleanup, 'duplicate blank lines')
        endif

        if index(options, 'r') >= 0
            var registers = split('abcdefghijklmnopqrstuvwxyz0123456789/-"', '\zs')

            for register in registers
                setreg(register, [])
            endfor

            silent add(cleanup, 'registers')
        endif

        silent cursor(ccursor)
        silent setpos('.', ccursor)
        silent setreg('/', lsearch)
        silent histdel('/', -1)

        if index(options, 'v') >= 0 && len(cleanup) > 0
            echo 'Cleaned-up: ' .. join(cleanup, ', ')
        endif
    enddef

    command! -nargs=0 CR Cleanup('vr')
    command! -nargs=0 CS Cleanup('vte')
    command! -nargs=0 CL Cleanup('vted')

    def Settitle(title: string): void
        if expand('%')[-3 :] ==? '!sh' || has('gui_running')
            return
        endif

        silent execute '!echo -ne "\033]30;' .. title .. '\007"'
    enddef

    def Postcolorscheme(): void
        if g:colors_name !=# 'miningbox'
            highlight! CursorLine cterm=NONE
            highlight! CursorLineNR cterm=NONE

            highlight! link VertSplit LineNr
            highlight! link SignColumn LineNr
            highlight! link EndOfBuffer LineNr
            highlight! link CursorLineSign LineNr

            highlight! link GitGutterAdd LineNr
            highlight! link GitGutterChange LineNr
            highlight! link GitGutterDelete LineNr
            highlight! link GitGutterChangeDelete LineNr

            highlight! link SignatureMarkText LineNr
            highlight! link SignatureMarkerText LineNr

            highlight! link User1 ErrorMsg
            highlight! link ExtraWhitespace Error

            g:fzf_colors = {
                'fg':      ['fg', 'Normal'],
                'bg':      ['bg', 'Normal'],
                'hl':      ['fg', 'Comment'],
                'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                'hl+':     ['fg', 'Statement'],
                'info':    ['fg', 'PreProc'],
                'prompt':  ['fg', 'Conditional'],
                'pointer': ['fg', 'Exception'],
                'marker':  ['fg', 'Keyword'],
                'header':  ['fg', 'Comment']
            }
        endif

        # @thanks https://github.com/junegunn/fzf.vim/issues/969
        $BAT_THEME = &background ==# 'light' ? 'gruvbox-light' : 'gruvbox-dark'

        return
    enddef

    # Avoid SafeState, VimEnter, BufEnter events!
    autocmd VimEnter * ++nested Viminfo() | Sessionload()

    if has('gui_running')
        # Load session when :cd command is executed
        # @thanks https://github.com/valacar/vimfiles/commit/4d0b79096fd1b2b6f5fc0c7225f7de7751fada64
        autocmd DirChangedPre global messages clear | Sessionsave() | silent! execute '1,$bdelete'
        autocmd DirChanged global Initialize(expand('<afile>')) | Viminfo() | Sessionload() | Statusline('x') | filetype detect
    endif

    autocmd BufEnter * Poststart()
    # BufEnter:     After changes between buffers
    # BufFilePost:  After changes name's current file
    autocmd BufEnter,BufFilePost * Settitle(join([GetNameCurrentPath(), GetNameCurrentFile()], ''))

    autocmd User ALELintPost Diagnostics()

    # BufWinEnter:  After cycling between buffers
    # BufHidden:    After close CTRL-W o
    autocmd WinEnter,BufWinEnter,BufHidden * Statusline(mode()) | setlocal cursorline
    autocmd WinLeave,BufWinLeave * setlocal nocursorline
    autocmd User UpdateStatusline Statusline(mode())
    autocmd User AsyncRunStart Statusline('t')
    autocmd User AsyncRunStop Statusline('f')
    # After open terminal with fzf
    autocmd ModeChanged *t:* Statusline(v:event.old_mode) | setlocal cursorline

    # Relative numbers on Insert Mode
    # autocmd WinLeave,InsertEnter * setlocal relativenumber
    # autocmd WinEnter,InsertLeave * setlocal norelativenumber

    autocmd ColorScheme * Postcolorscheme()
    autocmd FocusLost,BufWritePre *.vim,*.md,*.js,*.sh,*.php,*.twig,.vimrc,.vimrc.local,*.vue,config,*.xml,*.yml,*.yaml,*.snippets,*.vpm,*.conf,sshd_config,Dockerfile,*.sql Cleanup('te')

    # Create non-existent directories when saving files
    autocmd BufWritePre *.md if !isdirectory(expand('<afile>:p:h')) | mkdir(expand('<afile>:p:h'), 'p') | endif

    autocmd VimLeavePre * Sessionsave()
    autocmd VimLeave * Settitle('$USER@$HOST')
    # # Auto-source syntax in *.vpm
    # autocmd BufNewFile,BufRead *.vpm
    #     \ if filereadable(expand('syntax.vim')) |
    #     \   silent execute 'source ' .. expand('syntax.vim') |
    #     \ endif
    # # No resize in i3
    # autocmd VimResized * wincmd =
augroup END

nmap <silent> <F4> <ScriptCmd>GetHlinfo()<Enter>

# @thanks https://stackoverflow.com/questions/9464844/how-to-get-group-name-of-highlighting-under-cursor-in-vim#9464929
def GetHlinfo(): void
    if !exists("*synstack")
        return
    endif

    echo 'Highligth: ' .. join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), ',')
                \ .. ' -> ' .. synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
                \ .. ' -> ' .. g:colors_name
enddef

# nmap <silent> <F5> :presentation_mode()<Enter>
# nmap <silent> <S-F5> :set relativenumber! number! showmode! showcmd! hidden! ruler!<Enter>

# g:presentation_mode = 0

# function! s:presentation_mode()
#     maximum_column = 21
#     show_button_line = line('$') >= maximum_column

#     if g:presentation_mode == 0
#         g:presentation_mode = 1

#         silent setlocal colorcolumn=81
#         silent setlocal virtualedit+=all

#         if show_button_line
#             silent execute 'normal! mz' . maximum_column . 'G' . (&colorcolumn - 1) . "i-\e`z"
#         endif

#         silent execute 'highlight! link MaxLinePresentation CursorColumn'
#         silent execute 'match MaxLinePresentation /\%' . maximum_column . 'l/'
#     else
#         silent execute 'match'
#         silent execute 'highlight! clear MaxLinePresentation'

#         if show_button_line
#             silent execute 'normal! mz' . maximum_column . "G\"_D`z"
#         endif

#         silent setlocal virtualedit-=all
#         silent setlocal colorcolumn=

#         g:presentation_mode = 0
#     endif
# enddef

# Themes
# Allowed 24 bit colors, by default only accept 8 bit, tty!
# @see https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
# @see https://github.com/vim/vim/issues/993#issuecomment-255651605
if has('termguicolors')
    &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

    set t_Co=256                                                # Number colors, tty! (default: tty=8 konsole=256 gvim=16777216)
    set termguicolors                                           # Vivid colours? Please! (default: off)
endif

try
    execute 'colorscheme ' .. get(g:, 'colors_name', g:colorscheme)
catch /^Vim\%((\a\+)\)\=:E185/
    # Light:
    # - delek       <- +++++
    # - morning     <- +
    # - lunaperche  <- ++
    # - peachpuff   <- ++++
    # - shine       <- +
    # - zellner     <- +++

    # Dark:
    # - blue        <- ++++++
    # - darkblue    <- ++++++++++++++
    # - default     <- +
    # - desert
    # - elford
    # - evening
    # - habamax     <- ++
    # - industry
    # - koehler
    # - murphy
    # - pablo
    # - quiet       <- +++
    # - ron
    # - slate       <- ++++
    # - torte

    colorscheme default
endtry

if filereadable(expand('~/.vimrc.local'))
    source ~/.vimrc.local
endif

execute 'augroup END'

filetype on                                                     # Enable filetype detection, trigger FileType event (set filetype in buffer)
filetype plugin on                                              # Enable filetype detection plugin
filetype indent on                                              # Enable auto-indent detection

# @see https://vimhelp.org/syntax.txt.html#%3Asyntax-on
syntax enable                                                   # Enable syntax highlighting as is (on != enable), MUST BE after filetype
                                                                #   on    : Overrule your settings with the defaults
                                                                #   enable: Will keep most of your current color settings
defcompile                                                      # Compile functions so we get errors on startup.
