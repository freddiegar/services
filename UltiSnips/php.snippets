global !p
def autocomplete(t, options):
	if t:
		options =  [ m[len(t):] for m in options if m.startswith(t) ]
	if len(options) == 1:
		return options[0]

	return '|'.join(options)

def proptypes():
	return ['string', 'int', 'bool', 'float', 'DateTimeInterface', 'array']

def retutypes():
	return proptypes() + ['void']

def functypes():
	return ['public', 'protected', 'private']
endglobal

snippet nn "Get file name"
`!v sniphpets#basename()`
endsnippet

snippet pp "Define Property" b
$1`!p snip.rv=autocomplete(t[1], functypes())` $2`!p snip.rv=autocomplete(t[2], proptypes())` $$0;
endsnippet

snippet pc "Define Construct Property" b
$this->$1 = $$1;$0
endsnippet

snippet pt "Define Test Property" b
$$1 = '::$1::';$0
endsnippet

snippet pf "Define Fake Property" i
'::$1::'$0
endsnippet

snippet pa "Define Assert Property" b
$this->assertEquals($$1, $$2->$1());$0
endsnippet

snippet fis "Function Interface Set" b
public function set${1/^([a-z]){1}/\u$1/}($2`!p snip.rv=autocomplete(t[2], proptypes())` $$1): void;
endsnippet

snippet fig "Function Interface Get" b
public function $1(): $2`!p snip.rv=autocomplete(t[2], proptypes())`;
endsnippet

snippet fic "Function Interface Construct" b
public function __construct($0);
endsnippet

snippet fix "Function Interface X" b
public function $1($2): $3`!p snip.rv=autocomplete(t[3], retutypes())`;
endsnippet

snippet fif "Function Interface Full" b
public function $1(): $2`!p snip.rv=autocomplete(t[2], proptypes())`;

public function set${1/^([a-z]){1}/\u$1/}($2 $$1): void;
endsnippet

snippet ffs "Setter Function" b
public function set${1/^([a-z]){1}/\u$1/}($2`!p snip.rv=autocomplete(t[2], proptypes())` $$1): void
{
    $this->$1 = $$1;
}$0
endsnippet

snippet ffg "Getter Function" b
public function $1(): $2`!p snip.rv=autocomplete(t[2], proptypes())`
{
    return $this->$1;
}$0
endsnippet

snippet ffc "Function Construct" b
public function __construct($1 $$2$3)
{
    $this->$2 = $$2;$0
}
endsnippet

snippet ffx "Function X" b
$1`!p snip.rv=autocomplete(t[1], functypes())` function $2($3): $4`!p snip.rv=autocomplete(t[4], retutypes())`
{
    $0
}
endsnippet

snippet fff "Function Full" b
$3`!p snip.rv=autocomplete(t[3], functypes())` $2 $$1;

public function $1(): $2
{
    return $this->$1;
}

public function set${1/^([a-z]){1}/\u$1/}($2 $$1): void
{
    $this->$1 = $$1;
}$0
endsnippet

snippet fft "Function Test" b
public function test$1($2): void
{
    $0
}
endsnippet

snippet ffp "Use Data Provider" b
/**
 * @dataProvider get$0
 */
endsnippet

snippet ffd "Function Data Provider" b
public function get$1(): array
{
    return [
        [$0],
    ];
}
endsnippet

snippet rfg "Return For Getter"
return $this->`!v sniphpets#method()`;
endsnippet

snippet rfs "Return For Setter"
$this->`!v sniphpets#lcfirst(substitute(sniphpets#method(), 'set', '', ''))` = $`!v sniphpets#lcfirst(substitute(sniphpets#method(), 'set', '', ''))`;
endsnippet

snippet dd "Debug Dump"
dd($$1, __FILE__ . ':' . __LINE__);
endsnippet

snippet du "Debug Dump"
dump($$1, __FILE__ . ':' . __LINE__);
endsnippet

snippet php "Template Class" b
<?php

$0
endsnippet

snippet [] "Array" i
[
    $1 => $0,
]
endsnippet

snippet fn "Function" i
function
endsnippet

snippet "s(u|o|i)" "Scope" ir
`!p snip.rv='public' if match.group(1) == 'u' else ('protected' if match.group(1) == 'o' else 'private')`
endsnippet

snippet $ "This" i
$this->$0
endsnippet

snippet "tt(a|f)?c" "Template Class" br
<?php

namespace $1`!v sniphpets#namespace()`;

`!p snip.rv='abstract ' if match.group(1) == 'a' else ('final ' if match.group(1) == 'f' else '')`class `!v
sniphpets#basename()`
{
    ${VISUAL}$0
}
endsnippet

snippet tti "Template Interface" b
<?php

namespace $1`!v sniphpets#namespace()`;

interface `!v sniphpets#basename()`
{
    ${VISUAL}$0
}
endsnippet

snippet ttt "Template Trait" b
<?php

namespace $1`!v sniphpets#namespace()`;

trait `!v sniphpets#basename()`
{
    ${VISUAL}$0
}
endsnippet

snippet ttu "Template Test Unit" b
<?php

namespace $1`!v sniphpets#namespace()`;

final class `!v sniphpets#basename()` extends TestCase
{
    ${VISUAL}$0
}
endsnippet

snippet if "If"
if ($1) {
    ${VISUAL}$0
}
endsnippet

snippet else "Else"
 else {
    ${VISUAL}$0
}
endsnippet

snippet elif "Elseif"
 else if ($1) {
    ${VISUAL}$0
}
endsnippet

snippet fir "For loop"
for ($i = 0; $i ${1:<} $2; ++$i) {
    ${VISUAL}$0
}
endsnippet

snippet for "Foreach loop"
foreach ($1 as $1$2) {
    ${VISUAL}$0
}
endsnippet

snippet fas "Foreach key => val"
foreach ($1 as $${2:key} => $${3:value}) {
    ${VISUAL}$0
}
endsnippet

snippet "ar(f|m|r)" "Array operations" br
array_`!p snip.rv='filter' if match.group(1) == 'f' else ('map' if match.group(1) == 'm' else 'reduce')`($1)$0
endsnippet

snippet spr "Sprintf"
sprintf('$1', $0)
endsnippet

snippet try "Try/catch" b
try {
    ${VISUAL}$1
} catch (${1:Exception} $e) {
    $0
}
endsnippet

snippet "mt(i|s)" "Mark Test Incomplete" br
$this->markTest`!p snip.rv='Incomplete' if match.group(1) == 'i' else 'Skipped'`();$0
endsnippet

snippet eeu "Use exception" b
use $1Exception;$0
endsnippet

snippet eee "Throw a new exception" b
throw new $1Exception($2);$0
endsnippet

snippet eet "Check throw exception" b
$this->expectException($1Exception::class);
$this->expectExceptionMessage($2);$0
endsnippet
